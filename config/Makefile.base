## Maintained by: github.com/tkrop/go-make
## Manual: http://github.com/tkrop/go-make/MANUAL.md
##
## You can provide custom variables in \x1b[1;95mMakefile.vars\x1b[0m
## You can provide custom targets in \x1b[1;95mMakefile.ext\x1b[0m
SHELL := /bin/bash

# Setup variables for special purposes.
NULL :=
COMMA := ,
SPACE := $(NULL) $(NULL)
TAB := $(NULL)	$(NULL)
define NEWLINE


endef

# Setup colored message templates.
COLOR-info := 1;96
COLOR-debug := 1;94
COLOR-error := 1;91
COLOR-warning := 1;93
COLOR-failure := 1;91
COLOR-success := 1;92
COLOR-topic := 1;94
COLOR-cmd := 1;95
COLOR-target := 1;96

# Finding: \$\(call *[ce]*msg
ts = $$(date '+%F %T.%3N')
xifeq = $(if $(and $(findstring x$(1),x$(2)),$(findstring x$(2),x$(1))),$(3),$(4))
msg = $(strip \033[$(COLOR-$(1))m$(2)\033[0m $(3))
amsg = (("date '"'"'+%F %T.%3N'"'"'" | getline _msg_) > 0 ? \
	_msg_ : strftime("%F %T.000")) " $(call msg,$(1),$(1):,$(2))"
emsg = $(if $(2),echo -e "$(ts) $(call msg,$(1),$(1):,$(2))" >&2)
dmsg = $(if $(findstring --trace,$(MAKEFLAGS)),$(call emsg,$(1),$(2)),echo -n)

escape = $(subst $$,\$$,$(subst ",\",$(subst \",\\",$(1))))
cerror = $(if $(1),$(error $(shell $(call emsg,error,$(1)))))
cinfo = $(shell $(call emsg,info,$(1)))
cdebug = $(shell $(call dmsg,debug,$(1)))

# Check whether bash version is higher or equal version 3.2 to be compatible.
ifneq ($(shell echo $${BASH_VERSION} | grep -E -v "^([4-9]+|3\.2)"),)
  $(call cerror,bash version incompatible [$${BASH_VERSION}])
endif
# Check whether bash is running in minimal compatibility mode for testing.
ifdef BASH_COMPAT
  $(call cdebug,bash compatibility mode set [$(BASH_COMPAT)])
endif


# Setup default browser command to open coverage reports.
BROWSER ?= xdg-open

# Setup default versions used for building, releasing, and publishing.
VERSION ?= latest
IMAGE_VERSION ?= $(VERSION)
ifeq ($(wildcard VERSION),VERSION)
  BUILD_VERSION := v$(shell cat VERSION)
else
  BUILD_VERSION ?= $(VERSION)
endif

# Setup default module mode for building and testing.
mod-readonly = $(call xifeq,$(VERSION),latest,,-mod=readonly)

# Setup default variables for building, linking, and installing.
LDFLAGS ?=
LD_FLAGS ?= $(strip $(LDFLAGS))
LD_FLAGS_LINUX ?= $(strip -s -w $(LDFLAGS))
TESTFLAGS ?=
TEST_FLAGS ?= $(strip $(mod-readonly) -count=1 -race $(TESTFLAGS))
BUILDFLAGS ?= # -linkmode 'external' -extldflags '-static'
BUILD_FLAGS ?=  $(strip $(mod-readonly) -buildvcs=auto -trimpath $(BUILDFLAGS))
INSTALLFLAGS ?=
INSTALL_FLAGS ?= $(strip $(mod-readonly) -buildvcs=auto $(INSTALLFLAGS))

# Find container image command (docker, podman, or colima).
find-cmd-image := $(shell command -v docker || \
	command -v podman || command -v colima)
IMAGE_CMD ?= $(call find-cmd-image)

# Setup system default variables.
TMPDIR ?= /tmp
# Setup default go compiler environment.
export GO ?= go
export GOPATH ?= $(shell $(GO) env GOPATH)
export GOBIN ?= $(GOPATH)/bin
# Export private repositories that do not need to be downloaded.
export GOPRIVATE ?=

# Setup System dependent default variables.
export PATH := $(GOBIN):$(PATH)
ifeq ("$(shell uname)","Linux")
  $(call cdebug,using UNAME [$(shell uname --all)])
else ifeq ($(shell uname),Darwin)
  $(call cdebug,using UNAME [$(shell uname -a)])
  BREW_PREFIX ?= $(shell brew --prefix)
  path-setup = \
    if [ "$(1)" == "opt" ]; then \
      XPATH="$(BREW_PREFIX)/$(1)/$(2)/$(3)"; \
    else XPATH="$(BREW_PREFIX)/$(1)"; fi; echo -n "$${XPATH}:"; \
    if [ ! -e "$${XPATH}/$(4)" ]; then brew install $(2) >&2; fi;
  export PATH := $(shell $(call path-setup,bin,bash,,bash) \
    $(call path-setup,opt,coreutils,libexec/gnubin,ls) \
    $(call path-setup,opt,findutils,libexec/gnubin,find) \
    $(call path-setup,opt,gawk,libexec/gnubin,awk) \
    $(call path-setup,opt,gsed,libexec/gnubin,sed) \
    $(call path-setup,opt,make,libexec/gnubin,make))$(PATH)
  # Needs additional filters for testing.
  # export PATH := $(shell $(call path-setup,bin,curl,bin,curl))$(PATH)
  # Install and start colima if no image command found.
  #ifeq ($(call find-cmd-image),)
    # export PATH := $(shell $(call path-setup,opt,colima,bin,colima))$(PATH)
    # Needs additional testing to ensure colima is started.
    # $(shell brew colima start -f >&2)
  #endif
  # Ensure export of path to $(shell ...) in gmake 3.81.
  ifneq ($(shell echo $(MAKE_VERSION) | grep -E "^3\.[0-9]+"),)
    export SHELL :=  PATH="$(PATH)" $(BREW_PREFIX)/bin/bash
  else
    export SHELL := $(BREW_PREFIX)/bin/bash
  endif
else
  $(call cerror,unsupported operating system [$(shell uname -a)])
endif

# Log execution environment for debugging.
$(call cdebug,using SHELL [$${SHELL}])
$(call cdebug,using PATH [$${PATH}])
$(call cdebug,using SHELL [$${SHELL}])
$(call cdebug,using BASH [$${0} - $${BASH_VERSION}])
$(call cdebug,using AWK [$(shell echo | awk -W version 2>/dev/null)])

# Helper function to find and remove source files.
find-all = find $(1) ! -path "./.git/*" ! -path "./run/*" ! -path "./build/*" \
	\( $(2) \) 2>/dev/null | sed "s/^.\///g"
find-go = $(call find-all,$(1),-type f -regex "^[a-z0-9/_.-]*\.go$$" $(2))
clean-file = $(call find-all,$(1),-type f \( $(2) \) \
	-exec rm --verbose --force {} \;)
clean-dir = $(call find-all,$(1),-type d \( $(2) \) \
	-exec rm --verbose --force --recursive {} \;)
# Helper function for conversion of variables name.
upper = $(shell echo "$(1)" | tr '[:lower:]' '[:upper:]')


# Setup default makeflags create consistent behavior.
MAKEFLAGS += --warn-undefined-variables
MAKEFLAGS += --no-builtin-rules
MAKEFLAGS += --no-print-directory
MAKEFLAGS += --not-keep-going
MAKEFLAGS := $(sort $(MAKEFLAGS))

# Setup default directories of projects.
DIR_REAL := $(realpath $(CURDIR))
DIR_GIT := $(CURDIR)/.git
DIR_BUILD := $(CURDIR)/build
DIR_RUN := $(CURDIR)/run
DIR_CRED := $(DIR_RUN)/creds
DIR_CONFIG := $(HOME)/.config/go-make
DIR_TEMP := $(abspath $(TMPDIR))/go-make-$(USER)$(DIR_REAL)
$(call cdebug,using DIR_TEMP [$(DIR_TEMP)])

# Setup go-make to use desired build and config scripts.
GOMAKE_DEP := github.com/tkrop/go-make@v0.0.147
GOMAKE_PATH := $(GOPATH)/pkg/mod/$(GOMAKE_DEP)/config
GOMAKE_MAKEFILE := $(realpath $(firstword $(MAKEFILE_LIST)))
GOMAKE_CONFIG := $(patsubst %/,%,$(dir $(GOMAKE_MAKEFILE)))
GOMAKE_OPTIONS := --completion= --config= # "--async --detached --background"
GOMAKE_MODE ?=
$(call cdebug,using GOMAKE_PATH [$(GOMAKE_PATH)])
$(call cdebug,using GOMAKE_CONFIG [$(GOMAKE_CONFIG)])
$(call cdebug,using GOMAKE_MODE [$(GOMAKE_MODE)])

# Function to install the go-make version - if not available.
gomake-install = if [ ! -d "$(GOMAKE_PATH)" ] && \
	! [[ "$(GOMAKE_MAKEFILE)" =~ .*/config/Makefile.base ]]; then \
		$(GO) install $(GOMAKE_DEP) >/dev/null 2>&1 && \
		$(call emsg,info,installing go-make [$(GOMAKE_DEP)]) || \
		$(call emsg,failure,installing go-make [$(GOMAKE_DEP)]); \
	fi
# Call to ensure that we can find default config files.
$(shell $(gomake-install))

# Function to find files or return a fallback files.
find-fallback = $(if $(strip $(1)),$(strip $(1)),$(strip $(2)))
# Function to search for multiple files for inclusion.
find-make = $(call find-fallback,$(wildcard $(if \
		$(findstring :no-config:,:$(GOMAKE_MODE):),, \
		$(DIR_CONFIG)/$(1) $(DIR_CONFIG)$(DIR_REAL)/$(1)) $(1)), \
	$(firstword $(wildcard $(GOMAKE_CONFIG)/$(1) $(GOMAKE_PATH)/$(1))))

# Setup all default makefiles to be included.
MAKEFILE ?= $(call find-make,Makefile)
MAKEFILE_VARS ?= $(call find-make,Makefile.vars)
MAKEFILE_EXTS ?= $(call find-make,Makefile.ext)
$(call cdebug,using MAKEFILE [$(MAKEFILE)])
$(call cdebug,using MAKEFILE_LIST [$(MAKEFILE_LIST)])
$(call cdebug,using MAKEFILE_EXTS [$(MAKEFILE_EXTS)])
$(call cdebug,using MAKEFILE_VARS [$(MAKEFILE_VARS)])

# Include makefiles with custom variables.
include $(MAKEFILE_VARS)

# Function to search for default go-make config files.
find-config = $(firstword $(wildcard $(1) $(DIR_CONFIG)$(DIR_REAL)/$(1) \
	$(DIR_CONFIG)/$(1) $(GOMAKE_CONFIG)/$(1) $(GOMAKE_PATH)/$(1)))

# Setup dynamic config files to be used.
FILE_GOLANGCI ?= $(call find-config,.golangci.yaml)
FILE_MARKDOWN ?= $(call find-config,.markdownlint.yaml)
FILE_GITLEAKS ?= $(call find-config,.gitleaks.toml)
FILE_REVIVE ?= $(call find-config,revive.toml)
FILE_CODACY ?= $(call find-config,.codacy.yaml)
FILE_HEADER ?=

# Setup default files with special meaning.
FILE_IMAGE ?= Dockerfile
FILE_DEEPCOPY ?= zz_generated.deepcopy.go

# Setup files for caching targets.
FILE_TARGETS ?= $(DIR_TEMP)/targets
FILE_TARGETS_MAKE ?= $(FILE_TARGETS).make
FILE_TARGETS_GOMAKE ?= $(FILE_TARGETS).go-make


# Function to ensure compatibility of gawk and mawk.
awk-gensub = $(shell echo "false" | \
	awk '{ print gensub("false","true","g") }' 2>/dev/null)
ifneq ($(awk-gensub),true)
  awk-gensub = function gensub(r, s, h, t) { \
	  if (t == 0) { t = $$0 } \
	  if (h ~ "^[gG]") { gsub(r, s, t) } \
	  else if (int(h) != 0) { \
	    for (i = 1; i <= int(h); i++) { \
	      if (match(t, r)) { \
			 t = substr(t, 1, RSTART-1) s substr(t, RSTART+RLENGTH) \
		  } \
	    } \
	  } \
	  return t \
	}
  $(call cdebug,using GENSUB [$(awk-gensub)])
else
  awk-gensub =
endif
awk-color = $(awk-gensub) \
	function color(str) { \
	  return gensub("\\\\(033|x1b)", "\x1b", "g", str) \
	} \


# Setup go to use desired and consistent go versions.
GOVERSION ?= $(shell $(GO) version | \
	sed --regexp-extended "s/.*go([0-9.]+).*/\1/")
# GOVERSION ?= $(shell $(GO) version $$(which $(GO)) | \
# 	sed --regexp-extended "s/.*go([0-9.]+).*/\1/")
$(call cdebug,using GOVERSION [$(GOVERSION)])
# Function for checking and warning about go and package version mismatches.
go-check-version = \
	if [ -n "$$($(GO) version -v "$(GOBIN)/$(1)" 2>/dev/null)" ]; then \
	  MODULE="$(call go-pkg,$(TOOLS_GO),origin,^$(1)$$,,$(2))"; \
	  GOVERSION="$$($(GO) version -v "$(GOBIN)/$(1)" | sed "s/.*: go//")"; \
	  if [[ "$${GOVERSION}" != "$(GOVERSION)" ]]; then \
	    CHECK="$${GOVERSION} => $(GOVERSION)"; \
		$(call go-check-update,$(1),$${MODULE},$${GOVERSION}, \
		  build [$${CHECK}], or install matching compiler version); \
	  fi; \
	  if [ "$${MODULE\#\#*@}" != "latest" ]; then \
	    MPATH="$${MODULE%%@*}"; MPATH="$${MPATH%/cmd}"; \
	    MVERSION="$$($(call go-check-module,$(1),$${MPATH}))"; \
	    if [ "$${MVERSION}" != "$${MODULE\#\#*@}" ]; then \
	      CHECK="$${MVERSION} => $${MODULE\#\#*@}"; \
	      $(call go-check-update,$(1),$${MODULE},$${MVERSION}, \
	        version [$${CHECK}], to sync with project version); \
	    fi; \
	  fi; \
	elif [ "$(1)" != "go-make" ]; then $(call emsg,warning,$(1) not installed); \
	elif [ -f "$(GOBIN)/$(1)" ]; then $(call go-install-module,$(1),$(2)); fi
# Function to check go modules version.
go-check-module = $(GO) version -m "$(GOBIN)/$(1)" | \
	grep -E "^\s*(mod|dep)\s*$(2)" | cut -f 4
# Function to warn about automated updating of go packages.
go-check-update = \
	if [ "$(3)" != "(devel)" ]; then \
	  $(call emsg,info,$(1) $(4): updating binary now!); \
	  $(call go-install,$(1),$(2)); \
	else \
	  $(call emsg,warning,$(1) $(4): run 'make update-$(1)' $(5)); \
	fi
# Function to install go programs from package the go tooling list.
go-install-module = \
	$(call go-install,$(1),$(call go-pkg,$(TOOLS_GO),module,^$(1)$$,,$(2)))
go-install = \
	rm --force "$(GOBIN)/$(1)"; $(GO) install $(INSTALL_FLAGS) "$(2)"

# Function for determining the actual version of a go package from downloading.
VERSION_REGEX := 's/.*"Path":\s*"([^"]*)".*"Version":\s*"([^"]*)".*/\1@\2/g'
go-download-version = \
	$(GO) mod download --json $(1) 2>/dev/null | \
	  sed --regexp-extended --null-data $(VERSION_REGEX)
# Function to determine the latest version of a go package.
go-pkg-latest = \
	cd /; go list -m -versions $(1) 2>/dev/null | \
	awk '{ print $$(1) "@" $$(NF) }'; cd - >/dev/null
# Function for go-package handling (TODO: check spliting and simplifying).
go-pkg = $(shell awk -v mode="$(2)" -v filter="$(3)" \
      -v not="$(4)" -v version="$(5)" ' \
	BEGIN { FS = "[/@]"; RS = "[ \n\r]" } \
	function package(vindex) { \
	  if (vindex) { \
	    return substr($$0, 1, vindex - 1) \
	  } else { return $$0 } \
	} { \
	  field = NF; \
	  if (vindex = index($$0, "@")) { field-- } \
	  if ($$(field) ~ "v[0-9]+") { field-- } \
	  if (!filter || \
	      (not && ($$(field) !~ filter)) || \
	      (!not && ($$(field) ~ filter))) { \
	    if (mode == "command") { \
	      if (!($$(field) in map)) { \
	        print $$(field); map[$$(field)]++ \
	      } \
	    } else if (mode == "module") { \
	      if (!((pkg = package(vindex)) in map)) { \
	        if (version ~ "^[0-9.]+(-[0-9]{14}-[0-9a-f]{12})?$$") { \
	          print pkg ((version == "latest") ? "@latest" : "@v" version) \
	        } else { \
	          print ((vindex) ? $$0 : $$0 "@latest") \
	        } map[pkg]++ \
	      } \
	    } else if (mode == "origin") { \
	      if (!((pkg = package(vindex)) in map)) { \
	        print $$1 "/" $$2 "/" $$3 "@" \
	          ((vindex) ? substr($$0, vindex + 1) : "latest"); \
			map[pkg]++ \
	      } \
	    } else if (mode == "package") { \
	      if (!((pkg = package(vindex)) in map)) { \
	        print pkg; map[pkg]++ \
	      } \
	    } \
	  } \
	}' <<<"$(1)")

# Function to determine the actual go-make version.
gomake-version = $(shell if [ -f "$(GOBIN)/go-make" ]; then \
		$(call go-check-module,go-make,github.com/tkrop/go-make); \
	else echo "(devel)"; fi)

# https://github.com/kubernetes/code-generator/tags
K8S_CODEGEN_VERSION ?= v0.33.3
# https://github.com/golangci/golangci-lint/tags
GOLANGCI_VERSION ?= v1.64.8
# https://github.com/mgechev/revive/tags
# https://github.com/codacy/codacy-gorevive/blob/master/.tool_version
REVIVE_VERSION ?= v1.7.0

# Setup default tool command versions to be installed.
TOOLS_GO += \
	github.com/golangci/golangci-lint/cmd/golangci-lint@$(GOLANGCI_VERSION) \
	github.com/zalando/zally/cli/zally \
	golang.org/x/vuln/cmd/govulncheck \
	github.com/uudashr/gocognit/cmd/gocognit \
	github.com/fzipp/gocyclo/cmd/gocyclo \
	github.com/mgechev/revive@$(REVIVE_VERSION) \
	github.com/securego/gosec/v2/cmd/gosec \
	honnef.co/go/tools/cmd/staticcheck \
	github.com/zricethezav/gitleaks/v8 \
	github.com/icholy/gomajor \
	github.com/golang/mock/mockgen \
	github.com/tkrop/go-testing/cmd/mock \
	github.com/itchyny/gojq/cmd/gojq \
	github.com/mikefarah/yq/v4 \
	k8s.io/code-generator/cmd/deepcopy-gen@$(K8S_CODEGEN_VERSION) \
	k8s.io/code-generator/cmd/client-gen@$(K8S_CODEGEN_VERSION) \
	k8s.io/code-generator/cmd/lister-gen@$(K8S_CODEGEN_VERSION) \
	k8s.io/code-generator/cmd/informer-gen@$(K8S_CODEGEN_VERSION) \
	sigs.k8s.io/controller-tools/cmd/controller-gen \
	sigs.k8s.io/kind \
	$(GOMAKE_DEP)
TOOLS_SH += \
	github.com/anchore/syft \
	github.com/anchore/grype
TOOLS_NPM += \
	markdownlint-cli


# Check for the actually used go-make version.
#$(call cdebug, go-check-version = $(call \
	escape,$(call go-check-version,go-make,)))
$(shell $(call go-check-version,go-make,))

# Setup sensible defaults for workflow configuration variables.
IMAGE_PUSH ?= pulls
CODE_QUALITY ?= base
TEST_TIMEOUT ?= 10s

# Setup custom delivery files to be scanned for updating go versions.
DELIVERY := $(strip $(wildcard delivery*.yaml) $(wildcard .github/workflows/*.yaml))
DELIVERY_REGEX ?= (cdp-runtime\/go-|go-version: \^?)[0-9.]*
GOMOD_REGEX ?= ^(go )[0-9.]*$$

# Setup default git command and repository information.
GIT ?= git
GITHOOKS ?= pre-commit # commit-msg
GITAUTHOR ?= $$(echo -n "$$(git config --get user.name) <$$(git config --get user.email)>")
GITROOT := $(shell git rev-parse --show-toplevel 2>/dev/null || echo $(CURDIR))
GITURL := $(shell $(GIT) remote get-url origin 2>/dev/null | \
	sed "s/^https:\/\///; s/^git@//; s/.git$$//; s/^x-access-token:[^@]*@//; s/:/\//;")
GITHOST := $(word 1,$(subst /, ,$(GITURL)))
GITOWNER := $(word 2,$(subst /, ,$(GITURL)))
GITREPO := $(word 3,$(subst /, ,$(GITURL)))
GITNAME := $(GITOWNER)-$(GITREPO)
$(call cdebug,using GITURL [$(GITURL)])


# Function to determine the image name from the image file name.
image-name = echo -e "$(1)" | awk '$(awk-gensub) \
	BEGIN{ RS="[[:space:]]"; FS="/"; file=("$(1)" ~ "[[:space:]]") }; \
	($$0) { \
	  if ($$(NF) ~ "^$(FILE_IMAGE).+") { \
	    infix = "-" substr($$(NF), length("$(FILE_IMAGE)")+2); \
	  } else if ($$0 ~ "/$(FILE_IMAGE)$$") { infix = "-" $$(NF-1); \
	  } else { infix = ""; }; \
	  infix = gensub("[^[:alnum:]_.-]", "", "g", infix); \
	  add = (file != 0) ? "=" $$0: ""; \
	  print gensub(":", infix ":", "1", "$(IMAGE)" add); \
	}'
image-build-deps = echo | awk -v names="$(1)" '$(awk-gensub) \
	BEGIN { len = split(names, a, "[:= ]"); idx = 1; \
	  while (idx <= len) { files[a[idx]] = a[idx+2]; idx = idx+3; }; \
	  for (image in files) { file = files[image]; cmd = "cat " file; \
	    while ((cmd | getline) > 0) { if ($$1 == "FROM") { \
	      image = gensub(":.*", "", 1, ($$2 !~ "^--platform=") ? $$2 : $$3); \
	      if (image in files) { \
	        print "image-build/" file "::image-build/" files[image] ";"; \
		  }; \
	    }; }; close(cmd); \
	  }; \
	};'

#
# Legacy (Zalando-specific) team and image setup.
#
export IMAGE_REGISTRY ?= pierone.stups.zalan.do
export ZALLY_URL ?= https://infrastructure-api-linter.zalandoapis.com
export ZALLY_TOKEN ?=  $$(ztoken)
export TEAM ?= $(shell \
	if [ -f ".zappr.yaml" ]; then \
	  grep "X-Zalando-Team:" .zappr.yaml | \
	  sed "s/.*:[[:space:]]*\([a-z-]*\).*/\1/"; \
	else echo "${GITOWNER}"; fi)
export IMAGE_NAME ?= $(IMAGE_REGISTRY)/$(TEAM)/$(GITREPO)
ifneq ($(words $(subst :, ,$(subst /, ,$(IMAGE_NAME)))),3)
  $(call cerror,invalid base image name [$(IMAGE_NAME)] \
    - image name format [repo/team/name]!)
endif

# Setup default container image.
IMAGE := $(IMAGE_NAME):$(IMAGE_VERSION)
$(call cdebug,using IMAGE [$(IMAGE)])

# Setup default image variables.
IMAGE_FILES := $(shell $(call find-all,.,-type f -name "$(FILE_IMAGE)*"))
IMAGE_NAMES := $(shell $(call image-name,$(IMAGE_FILES)))


# Setup default database connection.
DB_HOST ?= 127.0.0.1
DB_PORT ?= 5432
DB_NAME ?= db
DB_USER ?= user
DB_PASSWORD ?= pass
DB_VERSION ?= latest
DB_IMAGE ?= postgres:$(DB_VERSION)

# Setup default aws startup settings.
AWS_SERVICES ?= sqs s3
AWS_VERSION ?= latest
AWS_IMAGE ?= localstack/localstack:$(AWS_VERSION)

# Setup java support.
JAVA_VERSION ?= 11.0.26+4
JAVA_HOME ?= $(GOBIN)/jdk-$(JAVA_VERSION)
JRE_VERSION ?= $(JAVA_VERSION)
JRE_HOME ?= $(GOBIN)/jre-$(JRE_VERSION)

# Setup codacy integration.
CODACY ?= enabled
ifeq ($(IMAGE_VERSION),latest)
  CODACY_CONTINUE ?= false
else
  CODACY_CONTINUE ?= true
endif
CODACY_PROVIDER ?= ghe
CODACY_USER ?= $(GITOWNER)
CODACY_PROJECT ?= $(GITREPO)
CODACY_API_BASE_URL ?= https://api.codacy.com
CODACY_CLIENTS ?= aligncheck
CODACY_BINARIES ?= gosec staticcheck
ifdef CODACY_JRE_HOME
  JRE_HOME := $(CODACY_JRE_HOME)
endif
# https://github.com/codacy/codacy-gosec/tags
CODACY_GOSEC_VERSION ?= 1.0.0
CODACY_GOSEC_EXTENSION ?= $(CODACY_GOSEC_VERSION)
# https://github.com/codacy/codacy-staticcheck/tags
CODACY_STATICCHECK_VERSION ?= 3.0.18
CODACY_STATICCHECK_EXTENSION ?= $(CODACY_STATICCHECK_VERSION)
# https://github.com/codacy/codacy-analysis-cli/tags
CODACY_ANALYSIS-CLI_VERSION ?= 7.9.25
CODACY_ANALYSIS-CLI_EXTENSION ?= assembly.jar
# https://github.com/codacy/codacy-coverage-reporter
ifneq ($(CODACY_API_BASE_URL),https://api.codacy.com)
	CODACY_REPORTER_VERSION ?= 13.13.13
else
	CODACY_REPORTER_VERSION ?=
endif
CODACY_API_TOKEN ?=
# Hack to ensure a fake token in CDP, iff no other token is provided.
CODACY_PROJECT_TOKEN ?= $(if $(CODACY_API_TOKEN),,$(if \
	$(wildcard /etc/ssl/certs/cdp-proxy.pem),"fake-token"))
$(call cdebug,using CODACY_API_TOKEN [$(CODACY_API_TOKEN)])
$(call cdebug,using CODACY_PROJECT_TOKEN [$(CODACY_PROJECT_TOKEN)])
$(call cdebug,using CODACY_API_BASE_URL [$(CODACY_API_BASE_URL)])
$(call cdebug,using CODACY_REPORTER_VERSION [$(CODACY_REPORTER_VERSION)])

KUBE_APIS ?= $(shell FILES=($$($(call find-go,.,-path "*/apis/*/*/*.go"))); \
	if [ -n "$${FILES}" ]; then grep -E "\+(kubebuilder|k8s)" "$${FILES[@]}" | \
	  sed "s|apis/[^/]*/[^/]*/[^/]*.go:.*|apis|" | sort --unique; \
	fi)
GEN_KUBE_APIS ?= $(KUBE_APIS:%=gen-kube-apis/%)
$(call cdebug,using GEN_KUBE_APIS [$(GEN_KUBE_APIS)])
GEN_KUBE_TARGETS := install-deepcopy-gen install-client-gen \
	install-lister-gen install-informer-gen install-controller-gen


# Default target list for all and pipeline builds.
TARGETS_ALL ?= init-hooks test lint build image
TARGETS_INIT ?= init-git init-hooks init-go init-make
TARGETS_COMMIT ?= test-go test-unit lint-leaks? lint-$(CODE_QUALITY) lint-markdown
TARGETS_TEST ?= test-all $(if $(filter $(CODACY),enabled),test-upload,)
TARGETS_LINT ?= lint-leaks? lint-$(CODE_QUALITY) lint-markdown lint-apis \
    $(if $(filter $(CODACY),enabled),lint-codacy,)
TARGETS_CLEAN ?= clean-build
TARGETS_UPDATE ?= update-go update-deps update-make

INIT_MAKE ?= $(notdir $(MAKEFILE) $(MAKEFILE_VARS) $(FILE_MARKDOWN) \
    $(FILE_CODACY) $(FILE_REVIVE))
UPDATE_MAKE ?=  $(notdir $(MAKEFILE) $(FILE_GOLANGCI) $(FILE_MARKDOWN) \
    $(FILE_GITLEAKS) $(FILE_CODACY) $(FILE_REVIVE))


# Stub function for general setup in run-targets (default: true).
run-setup ?= true
# Stub function for common variables in run-targets (called with one arg).
run-vars ?=
# Stub function for local variables in run-targets (called with one arg).
run-vars-local ?=
# Stub function for container specific variables in run-targets (called with one arg).
run-vars-image ?=
# Stub function to set up aws localstack run-target (default: true).
run-setup-aws ?= true

# General setup of tokens for run-targets.
run-token-create = \
	ztoken > $(DIR_CRED)/token; echo "Bearer" > $(DIR_CRED)/type
run-token-link = \
	test -n "$(1)" && test -n "$(2)" && test -n "$(3)" && ( \
		test -h "$(DIR_CRED)/$(1)-$(2)" || ln -s type "$(DIR_CRED)/$(1)-$(2)" && \
		test -h "$(DIR_CRED)/$(1)-$(3)" || ln -s token "$(DIR_CRED)/$(1)-$(3)" \
	) || test -n "$(1)" && test -n "$(2)" && test -z "$(3)" && ( \
	  test -h "$(DIR_CRED)/$(1)" || ln -s type "$(DIR_CRED)/$(1)" && \
	  test -h "$(DIR_CRED)/$(2)" || ln -s token "$(DIR_CRED)/$(2)" \
	) || test -n "$(1)" && test -z "$(2)" && test -z "$(3)" && ( \
	  test -h "$(DIR_CRED)/$(1)" || ln -s token "$(DIR_CRED)/$(1)" \
	) || true


# Setup default environment variables.
GEN_DIRS += $(strip $(KUBE_APIS:%/apis=%/clients) $(KUBE_APIS:%/apis=%/manifests))
$(call cdebug,using GEN_DIRS [$(GEN_DIRS)])
GEN_SOURCES += $(strip $(shell $(call find-go,.,-name "mock_*_test.go" -o \
		-name "mock_*.go" -o -name "zz_generated.*.go")) \
	$(shell if [ -n "$(GEN_DIRS)" ]; then $(call find-go,$(GEN_DIRS),); fi))
SOURCES := $(filter-out $(GEN_SOURCES),$(shell $(call find-go,.,)))
MODULES := $(shell echo $(SOURCES) | xargs -r dirname | sort --unique)
COMMANDS := $(shell $(call find-go,.,-name "main.go") | xargs -r readlink -f | \
	awk -F '/' '{ for ( field = NF-1; field > 0; field--) { \
	  if ($$field != "cmd") { print $$field; break; } \
	} }' | sort --unique)
COMMANDS_REGEX := $(shell echo "^$(COMMANDS)$$" | tr ' ' '|' )
COMMANDS_GO := $(sort $(call go-pkg,$(TOOLS_GO),command,$(COMMANDS_REGEX),not,))
COMMANDS_SH := $(sort $(call go-pkg,$(TOOLS_SH),command,$(COMMANDS_REGEX),not,))
COMMANDS_PKG := $(shell $(call find-go,.,-name "main.go") | xargs -r readlink -f | \
	awk -F '/' '$(awk-gensub) { for ( field = NF-1; field > 0; field--) { \
	  if ($$field != "cmd") { \
		target = gensub("/main.go", "", "1", gensub("$(CURDIR)", ".", "1")); \
	    print $$field "=" target; break; \
	  } \
	} }')

# Setup of runtime arguments for commands that support arguments.
CMDWORDS ?= call show git- test- lint run- version- update
CMDARGS ?= $(shell  awk '{ split("$(CMDWORDS)",seps); \
	  for (i = 1; i <= NF; i++) { if (found) { \
	    line = ((line) ? line " " $$i : $$i); continue \
	  } \
	  for (p in seps) { if ($$i ~ "^"seps[p] ) { found = 1; } } } \
	} END { print line }' <<<"$(MAKECMDGOALS)")
ARGS ?=
ifdef CMDARGS
  ARGS := $(strip $(CMDARGS) $(ARGS))
  $(eval $(subst :,\:,$(CMDARGS))::;@:)
endif
$(call cinfo,executing [make $(filter-out $(ARGS),$(MAKECMDGOALS)) ARGS=\"$(ARGS)\"])

# Optimized generation of mocks.
gen-mocks = \
	if [ -n "$(SOURCES)" ]; then \
	  grep "//go:generate[[:space:]]*mockgen" $(SOURCES) | \
	    $(gen-mocks-awk) | sort --unique; \
	fi
gen-mocks-awk = \
	awk '{ \
	  source = "_"; target = "_"; package = "_"; \
	  origin = substr($$1, 0, index($$1, "://go:generate") - 1); \
	  path = substr(origin, 0, match(origin, "/[^/]*$$")); \
	  for (i = 1; i <= NF; i++) { \
		if ($$i ~ "^-source=") { \
		  cmd = "readlink -f \"" path "/" substr($$i, 9) "\""; \
		  cmd | getline source; close(cmd) \
		} else if ($$i ~ "^-destination=") { \
		  cmd = "readlink -f \"" path "/" substr($$i, 14) "\""; \
		  cmd | getline target; close(cmd) \
		} \
	  } \
	  if (source == "_") { package = $$(NF-1) } \
	  print target "|" source "|" package "|" origin \
	}'

MOCKS := $(shell $(gen-mocks))
MOCKS_TARGETS := $(shell echo "$(MOCKS)"  | \
	awk 'BEGIN {FS="|"; RS=" "} ($$1 != "_") { print $$1 }' | sort --unique)
MOCKS_SOURCES := $(shell echo "$(MOCKS)" | \
	awk 'BEGIN {FS="|"; RS=" "} ($$2 != "_") { print $$2 }' | sort --unique)
MOCKS_ORIGINS := $(shell echo "$(MOCKS)" | \
	awk 'BEGIN {FS="|"; RS=" "} ($$4 != "_") { print $$4 }' | sort --unique)
$(call cdebug,using MOCKS [$(MOCKS)])

# Prepare target lists used to define rules and preconditions.
TARGETS_PUBLISH := $(addprefix version-publish-,all $(COMMANDS))
TARGETS_INIT_ALL := $(addprefix init/,$(sort $(INIT_MAKE) $(UPDATE_MAKE)))
TARGETS_INIT_MAKE := $(addprefix init/,$(INIT_MAKE))
TARGETS_INIT_CODACY := $(addprefix init-,$(CODACY_BINARIES) analysis-cli)
TARGETS_TEST_INIT := test-clean init-code
TARGETS_LINT_CODACY_CLIENTS := $(addprefix lint-,$(CODACY_CLIENTS))
TARGETS_LINT_CODACY_BINARIES := $(addprefix lint-,$(CODACY_BINARIES))
TARGETS_IMAGE_BUILD := $(addprefix image-build/,$(IMAGE_FILES))
TARGETS_IMAGE_PUSH := $(addprefix image-push/,$(IMAGE_FILES))
TARGETS_BUILD := $(addprefix build-,$(COMMANDS))
TARGETS_BUILD_LINUX := $(addprefix $(DIR_BUILD)/linux/,$(COMMANDS))
TARGETS_INSTALL := $(addprefix install-,$(COMMANDS))
TARGETS_INSTALL_GO := $(addprefix install-,$(COMMANDS_GO))
TARGETS_INSTALL_SH := $(addprefix install-,$(COMMANDS_SH))
TARGETS_INSTALL_NPM := $(addprefix install-,$(TOOLS_NPM:-cli=))
TARGETS_INSTALL_ALL := $(TARGETS_INSTALL) $(TARGETS_INSTALL_GO) \
	$(TARGETS_INSTALL_SH) $(TARGETS_INSTALL_NPM)
TARGETS_UNINSTALL := $(addprefix uninstall-,$(COMMANDS))
TARGETS_UNINSTALL_GO := $(addprefix uninstall-,$(COMMANDS_GO))
TARGETS_UNINSTALL_SH := $(addprefix uninstall-,$(COMMANDS_SH))
TARGETS_UNINSTALL_NPM := $(addprefix uninstall-,$(TOOLS_NPM:-cli=))
TARGETS_UNINSTALL_CODACY := $(addprefix uninstall-codacy-,$(CODACY_BINARIES))
TARGETS_UNINSTALL_ALL := \
	$(filter-out $(call xifeq,$(gomake-version),(devel),%-go-make,), \
	$(TARGETS_UNINSTALL) $(TARGETS_UNINSTALL_GO) $(TARGETS_UNINSTALL_SH) \
	$(TARGETS_UNINSTALL_NPM) $(TARGETS_UNINSTALL_CODACY))
TARGETS_RUN := $(addprefix run-, $(COMMANDS))
TARGETS_RUN_GO := $(addprefix run-go-, $(COMMANDS))
TARGETS_RUN_IMAGE := $(addprefix run-image-,$(if $(IMAGE_FILES),$(COMMANDS)))
TARGETS_RUN_CLEAN := $(addprefix run-clean-,$(if $(IMAGE_FILES),$(COMMANDS)) db aws)
TARGETS_CLEAN_ALL := clean-init $(TARGETS_CLEAN) clean-run $(TARGETS_UNINSTALL_ALL)
TARGETS_CLEAN_RUN := $(addprefix clean-run-,$(if $(IMAGE_FILES),$(COMMANDS)) db aws)
TARGETS_UPDATE_GO := $(addprefix update-,$(COMMANDS_GO))
TARGETS_UPDATE_SH := $(addprefix update-,$(COMMANDS_SH))
TARGETS_UPDATE_NPM := $(addprefix update-,$(TOOLS_NPM:-cli=))
TARGETS_UPDATE_MAKE := $(addprefix update/,$(UPDATE_MAKE))
TARGETS_UPDATE_MAKE? := $(addsuffix ?,$(TARGETS_UPDATE_MAKE))
TARGETS_UPDATE_ALL := update-go update-deps update-tools update-make
TARGETS_UPDATE_ALL? := update-go? update-deps? update-make?
TARGETS_UPDATE? := $(filter $(addsuffix ?,$(TARGETS_UPDATE)), \
	$(TARGETS_UPDATE_ALL?) $(TARGETS_UPDATE_MAKE?))


## Standard: default targets to test, lint, and build.
.DEFAULT:
	@if ! [[ "$(ARGS)" =~ *"$@"* ]]; then \
	  $(call emsg,error,unknown target [$@]); exit 1; \
	fi;

#@ executes the default targets.
all:: $(TARGETS_ALL)
#@ executes the default targets after cleaning up.
all-clean:: clean clean-run all
#@ executes the pre-commit check targets.
commit:: $(TARGETS_COMMIT)
#@ show short cut for show-help.
help:: show-help
# executes the given arguments as commands (for testing).
call::;	@$(ARGS)


$(DIR_TEMP) $(DIR_BUILD) $(DIR_RUN) $(DIR_CRED) $(GOBIN):
	@if [ ! -d "$@" ]; then mkdir --parents "$@"; fi;


## Make-Support: targets to support user understanding the functionality.
show-help = awk ' $(awk-color) \
	BEGIN { \
	  printf("\n$(call msg,topic,Usage:,) $(call msg,cmd,(go-)make, \
		) $(call msg,target,<target>,)\n") \
	} \
	/^\#\#/ { \
	  if (i = index($$0, ":")) { \
	    printf("\n$(call msg,topic,%s,)%s\n", \
	      color(substr($$0, 4, i - 4)), color(substr($$0, i))) \
	  } else { \
	    print color(substr($$0, 4)) \
	  } next \
	} \
	/^\#@ / { \
	  if (i = index($$0, ":")) { \
	    printf("  $(call msg,target,%-25s,) %s\n", \
	      color(substr($$0, 4, i - 4)), color(substr($$0, i + 2))) \
	  } else { line = substr($$0, 4) } next \
	} \
	/^[a-zA-Z_0-9?-]+:/ { \
	  if (line) { \
	    target = substr($$1, 1, length($$1) - 1); \
	    if (i = index(line, " \# ")) { \
	      target = target " " substr(line, 1, i - 1); \
	      line = substr(line, i + 3) \
	    } \
	    printf("  $(call msg,target,%-25s,) %s\n", target, color(line)); \
	    line = "" \
	  } \
	}'
show-vars = awk ' \
	($$0 ~ "^[[:alnum:]_-]* [?+]=") { \
	  if (comment) { print comment } print $$0; var = 1; next \
	} \
	(var && $$0 ~ "^([\t]|$$)") { \
	  print $$0; next \
	} \
	($$0 ~ "^\#") { \
	  comment = $$0; var = 0; next \
	} { \
	  comment = ""; var = 0; next \
	}'
show-targets = awk -v RS= -F: ' \
	/(^|\n)\# Files(\n|$$)/,/(^|\n)\# Finished / { \
	  if ($$1 !~ "^[\#./]") { print $$1 } \
	}'
show-options := \
	--question --no-builtin-rules --no-builtin-variables --print-data-base
show-options-all = sed 's|^ *-|-|; s|, *|\n|g;' | \
    sed '/^[^-].*$$/d; /^ *$$/d; s| .*$||; s|=.*|=|;' | \
	sed --regexp-extended 's|^(.*)\[=|\1\n\1=|; s|-.[ [].*||;'
show-options-long = grep --only-matching -- "--[^, ]*" | \
	sed --regexp-extended 's|=.*|=|; s|^(.*)\[=|\1\n\1=|;'

$(FILE_TARGETS) $(FILE_TARGETS_GOMAKE) $(FILE_TARGETS_MAKE): $(MAKEFILE_LIST)
	@$(call emsg,info,updating targets [$@]); mkdir --parents "$(DIR_TEMP)"; \
	if [ "$@" == "$(FILE_TARGETS_MAKE)" ]; then MAKEFILE="Makefile"; \
	else MAKEFILE="$(GOMAKE_MAKEFILE)"; TARGETS="$(GOMAKE_OPTIONS)"; fi; \
	( echo "$${TARGETS[@]}" | tr ' ' '\n'; \
	  make --help 2>&1 | $(show-options-long); \
	  $(MAKE) $(show-options) --makefile="$${MAKEFILE}" 2>/dev/null | \
	    $(show-targets) \
	) | grep -v "^\s*$$" | LC_ALL=C sort --unique > "$@";

#@ shows this short extracted help about main target families.
show-help::
	@cat $(MAKEFILE_LIST) | $(show-help) || true;
#@ shows all supported (customizable) variable (with defaults).
show-vars:
	@cat "$(GOMAKE_MAKEFILE)" | $(show-vars) || true;
#@ shows all supported targets and options.
show-targets: $(FILE_TARGETS)
	@cat "$(FILE_TARGETS)" || true;
show-targets-go-make: $(FILE_TARGETS_GOMAKE)
	@cat "$(FILE_TARGETS_GOMAKE)" || true;
show-targets-make: $(FILE_TARGETS_MAKE)
	@cat "$(FILE_TARGETS_MAKE)" || true;
#@ shows the raw base makefile as implemented.
show-raw:
	@cat "$(GOMAKE_MAKEFILE)" || true;
#@ shows the effective makefile as evaluated by make.
show-make:
	@$(MAKE) $(show-options) --makefile="$(GOMAKE_MAKEFILE)" 2>/dev/null || true;


## Git-Support: targets for standard git commands (experimental).
GITFIX ?= $(GIT) commit --amend --no-edit
GITPUSH ?= $(GIT) push --force-with-lease
GITBRANCH ?= $(GIT) branch --show-current
GITPRUNE ?=$(GIT) fetch --all --prune --verbose
GITTIP ?= $(GIT) log --max-count=1 --pretty=format:"%T"
GITHASH ?= $(GIT) log --max-count=1 --pretty=format:"%H"
GITLOG ?= $(GIT) log --pretty=format
# https://github.com/pvdlg/conventional-changelog-metahub#commit-types
COMMIT_CONVENTION ?= feat deprecate remove docs fix style refactor \
	perf test build ci chore
git-branch = \
	$$(if [ -n "$(1)" ] && [ "$(1)" != "all" ]; then echo "$(1)"; \
	else echo "$(git-branch-main)"; fi)
git-branch-main = \
	$$(git symbolic-ref refs/remotes/origin/HEAD | sed 's|^refs/remotes/origin/||')
git-number = \
	$$(if command -v gh >/dev/null 2>&1; then \
	  ( gh pr list --state all --json "number" --limit 1 || exit 1; \
	  gh issue list --state all --json "number" --limit 1 || exit 1; ) | \
	  jq --slurp --raw-output '.[] | .[].number'; \
	else \
	  $(GITLOG):"%s" | grep -Eo "[(,]\#[0-9]+" | sed "s|.*[,(]\#||g"; \
	fi | sort --numeric-sort --reverse | head --lines=1 | \
	while read NUM; do echo $$((NUM + 1)); done)
git-message = \
	if [ -z "$${MESSAGE}" ]; then MESSAGE="chore: update deps"; fi; \
	if ! [[ "$${MESSAGE}" =~ ^[^:]+:.*$$ ]]; then MESSAGE="$(1): $${MESSAGE}"; fi; \
	if ! [[ "$${MESSAGE}" =~ ^.*\([^()]*\#[0-9]+\)$$ ]]; then \
	  MESSAGE="$${MESSAGE} (\#$(2))"; \
	fi
git-clean = \
	$(GITPRUNE); HISTORY=($$($(GIT) log --pretty=format:"%T" "$${MAIN}")); \
	for BRANCH in $$($(GIT) branch | cut -c 3- | grep -vw "$(1)"); do \
	  TIP="$$($(GITTIP) "$${BRANCH}")"; \
	  if [[ "$${HISTORY[@]}" =~ $${TIP} ]]; then \
	    $(GIT) branch --delete --force "$${BRANCH}"; \
	  elif [ "$(2)" == "all" ]; then \
	    $(GIT) branch --delete "$${BRANCH}"; \
	  else $(call emsg,info,keeping branch [$${BRANCH}]); \
	  fi; \
	done; $(GITPRUNE)
git-verify = awk -v mode="$(1)" -v author="$(GITAUTHOR)" '$(awk-gensub) \
	BEGIN { \
	  re_type_suffix = "((\\[|\\()[a-z]+(\\]|\\)))?!?: "; \
	  re_type_missing = "^([a-z]+)" re_type_suffix; \
	  re_type_invalid = "^(" gensub(" ", "|", "g", \
	    "$(COMMIT_CONVENTION)") ")" re_type_suffix; \
	  re_issue = "([a-z]+/[a-z]+)?\#[0-9]+"; \
	  re_issue_list = "\\(" re_issue "((,|\\) *\\()" re_issue ")*\\)"; \
	  re_issue_missing = re_issue_list "$$"; \
	  re_issue_invalid = "^[^(]*" re_issue_list "$$"; \
	  signed_by = "Signed-off-by:"; \
	  re_signed_missing = signed_by " +[^\\n]*$$"; \
	  re_signed_author = "^" signed_by " +" author "$$"; \
	} \
	function verify() { \
	  msg = gensub("((:?\\n)\#[^\\n]*|\\n)*$$", "", "g", msg); \
	  title = (i = index(msg,"\n")) ? substr(msg, 0, i - 1) : msg; \
	  if (title !~ re_type_missing) { \
	    printf($(call amsg,error,commit type missing \
		  [title=%s]\n), title); errors++ \
	  } else if (title !~ re_type_invalid) { \
	    printf($(call amsg,error,commit type invalid \
		  [title=%s]\n), title); errors++ \
	  } \
	  if (title !~ re_issue_missing) { \
	    printf($(call amsg,error,issue missing \
		  [titel=%s]\n), title); errors++ \
	  } else if (title !~ re_issue_invalid) { \
	    printf($(call amsg,error,issue invalid \
		  [titel=%s]\n), title); errors++ \
	  } \
	  sign = (i = index(msg, signed_by)) ? substr(msg, i) : ""; \
	  if (sign !~ re_signed_missing) { \
	    printf($(call amsg,error,signed-off-by missing \
		  [msg=%s]\n), msg); errors++ \
	  } else if (sign !~ "^" re_signed_missing) { \
		printf($(call amsg,error,signed-off-by by to many \
		  [sign=%s]\n), sign); errors++ \
	  } else if (mode == "message" && sign !~ re_signed_author) { \
		printf($(call amsg,error,signed-off-by not the author \
		  [sign=%s; author=%s]\n), sign, author); errors++ \
	  } msg = "" \
	} \
	(mode == "message") { \
	  if (msg != "") { \
		msg = msg "\n" $$0 \
	  } else { msg = $$0 } next \
	} \
	(mode != "message" && $$0 ~ "^    ") { \
	  if (msg != "") { \
		msg = msg "\n" substr($$0, 5) \
	  } else { msg = substr($$0, 5) } next \
	} \
	(mode != "message") { if (msg) { verify(); } } \
	END { \
	  if (mode == "message" || msg) { verify(); } if (errors) { \
	    printf($(call amsg,failure,git-verify $(ARGS) \
		  [errors=%d]\n), errors); exit 1 \
	  } \
	  printf($(call amsg,success,git-verify $(ARGS) \
	    [errors=%d]\n), errors) \
	}'

GITFORMAT ?= "%Cred%h %t %Cgreen%ad%Creset | %s %C(bold blue)[%an]%Creset%C(yellow)%d%Creset"
#@ prints the git log of a branch in pretty short format.
git-log::
	@$(GIT) log --graph --date=iso --pretty=format:$(GITFORMAT);
#@ prints the git log of all branches as graph in pretty short format.
git-graph::
	@$(GIT) log --graph --date=iso --all --pretty=format:$(GITFORMAT);
#@ [all] # cleans up the git history removing merged branches except the current.
git-clean::
	@BRANCH="$$($(GITBRANCH))"; MAIN="$(call git-branch,$(ARGS))"; \
	$(call git-clean,$${MAIN}\|$${BRANCH},$(ARGS));
#@ [all] # checks out default branch and cleans up the git history removing merged branches.
git-reset::
	@BRANCH="$$($(GITBRANCH))"; MAIN="$(call git-branch,$(ARGS))"; \
	if [ "$${BRANCH}" != "$${MAIN}" ]; then \
	  $(GIT) checkout "$${MAIN}" && $(GIT) pull || ( \
	    $(GIT) stash && $(GIT) checkout "$${MAIN}" && \
		$(GIT) pull && $(GIT) stash apply \
	  ) \
	fi || exit 1; $(call git-clean,$${MAIN},$(ARGS));
#@ <mode> [msg|log-file] # checks whether git log follows the commit conventions.
git-verify::
	@$(call dmsg,info,git-verify); MODE="$(firstword $(ARGS))"; \
	case "$${MODE}" in \
	( "log" ) cat "$(wordlist 2,$(words $(ARGS)),$(ARGS))";; \
	( "message" ) cat "$(wordlist 2,$(words $(ARGS)),$(ARGS))";; \
	( "branch" ) $(GIT) log --no-merges --format=raw "$$($(GITBRANCH))";; \
	( "pull" | * ) MAIN="$(call git-branch,$(wordlist 2,2,$(ARGS)))" && \
	  $(GIT) fetch origin "$${MAIN}" --verbose && \
	  $(GIT) log --no-merges --format=raw "$$($(GITBRANCH))" "^origin/$${MAIN}";; \
	esac | $(call git-verify,$${MODE}) >&2;

#@ <branch> <message> # creates a branch with the current change set using next issue.
git-create:: git-create-feat
# TODO: check whether I'm on the default branch and on remote HEAD.
$(addprefix git-create-,$(COMMIT_CONVENTION)):: git-create-%:
	@BRANCH="$(firstword $(ARGS))"; \
	if [ -z "$${BRANCH}" ]; then BRANCH="update-deps"; fi; \
	MESSAGE="$(wordlist 2,$(words $(ARGS)),$(ARGS))"; \
	$(call git-message,$*,$(git-number)); \
	$(call emsg,info,git-create [$${BRANCH} - $${MESSAGE}]); \
	$(GIT) checkout -B "$${BRANCH}" && \
	ARGS="" $(GIT) commit --signoff --message="$${MESSAGE}" && \
	$(GIT) push --set-upstream origin "$${BRANCH}" && \
	if command -v gh >/dev/null 2>&1; then \
	  gh pr create --base "$(git-branch-main)" --head "$${BRANCH}" \
	    --draft --assignee "@me" --title "$${MESSAGE}"; \
	fi || $(GIT) checkout "$${BRANCH}"; exit 0;
#@ <message> # commits the current change set using the given message with current issue.
git-commit:: git-commit-feat
$(addprefix git-commit-,$(COMMIT_CONVENTION)):: git-commit-%:
	@NUMBER="$$($(GITLOG):"%s" $(git-branch-main)..HEAD | \
	grep -Eo "[(,]\#[0-9]+" | sed "s|.*[,(]\#||g" | head --lines=1)"; \
	if [ -z "$${NUMBER}" ]; then NUMBER="$(call git-number)"; fi; \
	MESSAGE="$(ARGS)"; $(call git-message,$*,$${NUMBER}); \
	$(call emsg,info,git-commit [$${MESSAGE}]); \
	ARGS="" $(GIT) commit --signoff --message "$${MESSAGE}"; exit 0;
#@ [(no-)edit|(no-)verify] # pushes the latest changes to the previous commit of the origin.
TARGETS_GIT_FIX := git-fix git-fix-all git-fix-edit git-fix-no-edit git-fix-verify git-fix-no-verify
$(TARGETS_GIT_FIX):: git-fix%:
	@ARGS=" $(ARGS) $(*:-%=%) "; \
	if [[ "$${ARGS}" =~ " all " ]]; then git add .; fi; \
	GITFIX=($(patsubst %,"%",$(GITFIX))); GITPUSH=($(patsubst %,"%",$(GITPUSH))); \
	if [[ "$${ARGS}" =~ " verify " ]]; then GITFIX=("$${GITFIX[@]/--no-verify}"); fi; \
	if [[ "$${ARGS}" =~ " no-verify " ]]; then GITFIX+=("--no-verify"); fi; \
	if [[ "$${ARGS}" =~ " edit " ]]; then GITFIX=("$${GITFIX[@]/--no-edit}"); fi; \
	if [[ "$${ARGS}" =~ " no-edit " ]]; then GITFIX+=("--no-edit"); fi; \
	for KEY in "$${!GITFIX[@]}"; do \
	  if [ "$${GITFIX[$${KEY}]}" == "" ]; then unset GITFIX[$${KEY}]; fi; \
	done; \
	echo "$${GITFIX[@]} && $${GITPUSH[@]}"; \
	ARGS="" "$${GITFIX[@]}" && $${GITPUSH[@]}; exit 0;
#@ pushes the current branch to the same branch of the origin.
git-push::
	@$(GIT) push --set-upstream origin \
	  $$($(GIT) branch 2> /dev/null | sed '/^[^*]/d; s/* \(.*\)/\1/');


## Init: targets to initialize tools and (re-)sources.

#@ initialize the project to prepare it for building.
init:: $(TARGETS_INIT)
#@ initialize the project with git revision management.
init-git:
	@if [ ! -d "$(DIR_GIT)" ]; then \
	  $(call emsg,info,initializing repository [$(DIR_GIT)]); \
	  $(GIT) init; \
	fi;
#@ initialize git pre-commit and commit-message hooks.
init-hooks:: $(GITHOOKS:%=$(DIR_GIT)/hooks/%)
git-hooks-commit-msg = echo -ne '\#!/bin/sh\n\n\
	command -v $(GOBIN)/go-make >/dev/null || \\\n\
	GOBIN=$(GOBIN) $(GO) install $(INSTALL_FLAGS) $(GOMAKE_DEP) && \\\n\
	$(GOBIN)/go-make git-verify message $${1};\n' | sed 's/^ *//g'
git-hooks-pre-commit = echo -ne '\#!/bin/sh\n\n\
	command -v $(GOBIN)/go-make >/dev/null || \\\n\
	GOBIN=$(GOBIN) $(GO) install $(INSTALL_FLAGS) $(GOMAKE_DEP) && \\\n\
	$(GOBIN)/go-make commit;\n' | sed 's/^ *//g'
$(DIR_GIT)/hooks/commit-msg: $(MAKEFILE_LIST)
	@if ! [[ ":$(GOMAKE_MODE):" =~ .*":no-hooks:".* ]] && [ -d "$(DIR_GIT)/hooks" ] && \
		! diff <(cat $@ 2>/dev/null) <($(git-hooks-commit-msg)) >/dev/null; then \
	  $(git-hooks-commit-msg) >$@; chmod 755 $@; \
	fi;
$(DIR_GIT)/hooks/pre-commit: $(MAKEFILE_LIST)
	@if ! [[ ":$(GOMAKE_MODE):" =~ .*":no-hooks:".* ]] && [ -d "$(DIR_GIT)/hooks" ] && \
		! diff <(cat $@ 2>/dev/null) <($(git-hooks-pre-commit)) >/dev/null; then \
	  $(git-hooks-pre-commit) >$@; chmod 755 $@; \
	fi;

#@ initialize the go module and package dependencies.
init-go:: go.mod
go.mod: go.sum
go.sum: $(SOURCES)
	@$(call emsg,info,updating [go.mod&go.sum]);
	$(if $(SOURCES),$(if go.mod,,$(GO) mod init "$(GITURL)" &&) \
	  $(GO) mod tidy -x -v -e -compat=$(GOVERSION) && \
	  touch go.mod go.sum && $(GO) mod download;)

#@ initialize the generated sources.
init-code:: init-hooks $(MOCKS_TARGETS) gen-kube-apis
$(MOCKS_TARGETS): go.sum $(MOCKS_SOURCES) install-mockgen install-mock
	@MOCK=($(subst |,$(SPACE),$(firstword $(filter $@|%,$(MOCKS))))); \
	TARGET="$${MOCK[0]}"; SOURCE="$${MOCK[1]}"; \
	PACKAGE="$${MOCK[2]}"; ORIGIN="$${MOCK[3]}"; \
	if [ ! -f "$${TARGET}" ]; then \
	  echo "$(GO) generate \"$${ORIGIN}\""; $(GO) generate "$${ORIGIN}"; \
	elif [ "$${SOURCE}" != "_" -a "$${TARGET}" -ot "$${SOURCE}" ]; then \
	  echo "$(GO) generate \"$${ORIGIN}\""; $(GO) generate "$${ORIGIN}"; \
	elif [ "$${PACKAGE}" != "_" -a "$${TARGET}" -ot "go.sum" ]; then \
	  echo "$(GO) generate \"$${ORIGIN}\""; $(GO) generate "$${ORIGIN}"; \
	fi;

#@ initialize the codacy support.
init-codacy:: $(TARGETS_INIT_CODACY) init-jre
$(TARGETS_INIT_CODACY):: init-%:
	@VERSION="$(CODACY_$(call upper,$*)_VERSION)"; \
	EXTENSION="$(CODACY_$(call upper,$*)_EXTENSION)"; \
	if [ -z "$${EXTENSION}" ]; then EXTENSION="$${VERSION}"; fi; \
	FILE="$(GOBIN)/codacy-$*-$${VERSION}"; \
	if [ ! -f $${FILE} ]; then \
	  BASE="https://github.com/codacy/codacy-$*/releases/download"; \
	  echo curl --silent --location --output $${FILE} \
	    $${BASE}/$${VERSION}/codacy-$*-$${EXTENSION}; \
	  curl --silent --location --output $${FILE} \
	    $${BASE}/$${VERSION}/codacy-$*-$${EXTENSION}; \
	  chmod 700 $${FILE}; \
	fi;

# initialize java development and java runtime support.
init-jre init-java:: init-%:
	@DIR="$($(call upper,$*)_HOME)"; \
	if [ ! -d "$${DIR}" ]; then VERSION="$($(call upper,$*)_VERSION)"; \
	  case "$$(uname)" in (Linux) OS="linux";; (Darwin) OS="mac";; esac; \
	  case "$$(uname -m)" in (x86_64) CPU="x64";; (arm64) CPU="aarch64";; esac; \
	  XFILE="OpenJDK$${VERSION%%.*}U-$*_$${CPU}_$${OS}_hotspot_$${VERSION/+/_}.tar.gz"; \
	  XPATH="temurin$${VERSION%%.*}-binaries/releases/download/jdk-$${VERSION}"; \
	  FILE="/tmp/temurin-$*-$${VERSION}.tar.gz"; \
	  if [ ! -f "$${FILE}" ]; then \
	    $(call emsg,info,downloading $*-$${VERSION} [$${DIR}]); \
	    CMD=(curl --silent --location --show-error --fail \
		  "https://github.com/adoptium/$${XPATH}/$${XFILE}" \
		  --output "$${FILE}"); \
		echo $${CMD[@]}; $${CMD[@]}; \
	  fi; \
	  if [ -f "$${FILE}" ]; then mkdir --parents "$${DIR}"; \
	    $(call emsg,info,installing $*-$${VERSION} [$${DIR}]); \
	    case "$$(uname)" in (Linux) SUB="1";; (Darwin) SUB="3";; esac; \
	    tar -C "$${DIR}" "--strip-components=$${SUB}" -zxf "$${FILE}"; \
	  fi; \
	fi;

#@ <version> # initialize project by copying config files from template.
init-make:: $(TARGETS_INIT_MAKE)
$(TARGETS_INIT_ALL):: init/%:
	@DIR="$${PWD}"; FILE="$*"; #FILE="$${FILE##$${DIR}/}"; \
	if [ ! -f "$${DIR}/$${FILE}" -o "$(ARGS)" == "current" ]; then \
	  echo "install: $${FILE} (installed)"; \
	  cp "$(GOMAKE_CONFIG)/$${FILE}" "$${DIR}/$${FILE}"; \
	else \
	  $(call emsg,warning,installing: $${FILE} (blocked)); \
	fi;

#@ <version> # initialize project by copying Makefile.base from template.
init-make!::
	cp "$(GOMAKE_CONFIG)/Makefile.base" "Makefile";


## Generate: targets to generate code and documentation.

#@ generate kubernetes api clients and manifests.
gen-kube-apis:: $(GEN_KUBE_APIS)
$(GEN_KUBE_APIS):: gen-kube-apis/%: $(GEN_KUBE_TARGETS)
	@HEADER="$(FILE_HEADER)"; BPKG="$*"; BPKG="$${BPKG%/apis}"; \
	if [ -d "$${BPKG}/clients" ] && [ -d "$${BPKG}/manifests" ] && \
	   [ -z "$$(find $${BPKG}/{apis,clients,manifests} -type f \
	    ! -name "$(FILE_DEEPCOPY)" -printf '%T@ %p\n' 2>/dev/null | \
	    sort -rn | head -1 | grep "$${BPKG}/apis/")" ]; then \
	  $(call emsg,info,generating apis skipped [$${BPKG}]); exit 0; \
	else $(call emsg,info,generating apis [$${BPKG}]); fi; \
	\
	$(GO) get k8s.io/api/core/v1; \
	for APKG in $$(find $${BPKG} -path "*/apis/*/*" -type d); do \
	  MANDIR="$${BPKG}/manifests"; \
	  APIPKG="$(GITURL)/$${APKG}"; APIBPKG="$${APIPKG%/*/*}"; \
	  CLIDIR="$${BPKG}/clients"; CLIPKG="$(GITURL)/$${CLIDIR}"; \
	  $(call emsg,info,generating manifests [$${APKG}]); \
	  $(GOBIN)/controller-gen crd:crdVersions=v1 paths=./$${BPKG}/apis/... \
	    "output:crd:dir=$${MANDIR}"; \
	  $(call emsg,info,generating deepcopy [$${APKG}]); \
	  $(GOBIN)/deepcopy-gen --go-header-file="$${HEADER}" \
	    --output-file="$(FILE_DEEPCOPY)" --bounding-dirs="$${APIBPKG}" \
	    "$${APIPKG}"; \
	  $(call emsg,info,generating clients [$${APKG}:clientsets]); \
	  $(GOBIN)/client-gen --go-header-file="$${HEADER}" \
	    --clientset-name=versioned --input-base="" --input="$${APIPKG}" \
	    --output-pkg="$${CLIPKG}/clientset" --output-dir="$${CLIDIR}/clientset"; \
	  $(call emsg,info,generating clients [$${APKG}:listeners]); \
	  $(GOBIN)/lister-gen --go-header-file="$${HEADER}" \
	    --output-pkg="$${CLIPKG}/listers" --output-dir="$${CLIDIR}/listers" \
	    "$${APIPKG}"; \
	  $(call emsg,info,generating clients [$${APKG}:informers]); \
	  $(GOBIN)/informer-gen --go-header-file="$${HEADER}" \
	    --versioned-clientset-package="$${CLIPKG}/clientset/versioned" \
	    --output-pkg="$${CLIPKG}/informers" --output-dir="$${CLIDIR}/informers" \
	    --listers-package="$${CLIPKG}/listers" "$${APIPKG}"; \
	done; \
	$(call emsg,info,updating packages [$${BPKG}]); \
	$(GO) get ./$${BPKG}/clients/...;


## Test: targets to test the source code (and compiler environment).
TEST_ALL := $(DIR_BUILD)/test-all.cover
TEST_UNIT := $(DIR_BUILD)/test-unit.cover
TEST_BENCH := $(DIR_BUILD)/test-bench.cover

#@ execute default test set.
test:: $(TARGETS_TEST)
#@ <pkg>[/<test>] # execute all tests.
test-all:: $(TARGETS_TEST_INIT) $(TEST_ALL)
#@ <pkg>[/<test>] # execute only unit tests.
test-unit:: $(TARGETS_TEST_INIT) $(TEST_UNIT)
#@ <pkg>[/<test>] # execute benchmarks.
test-bench:: $(TARGETS_TEST_INIT) $(TEST_BENCH)

# remove all coverage files of test and benchmarks.
test-clean::
	@rm --verbose --force $(TEST_ALL) $(TEST_UNIT) $(TEST_BENCH);

#@ start the test coverage report.
test-cover::
	@FILE=$$(ls -Art "$(TEST_ALL)" "$(TEST_UNIT)" \
	  "$(TEST_BENCH)" 2>/dev/null); \
	$(GO) tool cover -o "$${FILE}.html" -html="$${FILE}"; \
	if [ "$(ARGS)" == "white" ]; then \
	  sed --in-place 's/black/whitesmoke/g' "$${FILE}.html"; \
	fi; \
	sensible-browser "$${FILE}.html";

#	$(GO) tool cover -html="$${FILE}"; \

#@ upload the test coverage report to codacy.
test-upload::
	@FILE=$$(ls -Art "$(TEST_ALL)" "$(TEST_UNIT)" \
	  "$(TEST_BENCH)" 2>/dev/null); COMMIT="$$($(GITHASH))"; \
	SCRIPT="https://coverage.codacy.com/get.sh"; \
	LARGS=("--language=go" "--force-coverage-parser=go"); \
	LARGS+=("--codacy-api-base-url=$(CODACY_API_BASE_URL)"); \
	LARGS+=("--commit-uuid=$${COMMIT}" "--skip"); \
	if [ -n "$(CODACY_PROJECT_TOKEN)" ]; then \
	  LARGS+=("--project-token=$(CODACY_PROJECT_TOKEN)"); \
	elif [ -n "$(CODACY_API_TOKEN)" ]; then \
	  LARGS+=("--organization-provider=$(CODACY_PROVIDER)"); \
	  LARGS+=("--username=$(CODACY_USER)"); \
	  LARGS+=("--project-name=$(CODACY_PROJECT)"); \
	  LARGS+=("--api-token=$(CODACY_API_TOKEN)"); \
	else $(call emsg,info,uploading coverage report (skipped)); exit 0; fi; \
	bash <(curl --silent --location $${SCRIPT}) \
	  report "$${LARGS[@]}" --coverage-reports=$${FILE} && \
	$(call emsg,info,uploading coverage report (uploadad)) || \
	$(call emsg,info,uploading coverage report (failed));

#@ test whether project creates conflicting program names.
test-build::
	@echo -e "$(COMMANDS_PKG)" | awk 'BEGIN{ RS=" "; FS="="; \
	  fmt = $(call amsg,error,program conflict [%s && %s => %s]\n) \
	} { if ($$1 in cmds) { failures++; \
	    printf(fmt, cmds[$$1], $$2 "/main.go", $$1 "/main.go") \
	} cmds[$$1] = $$2 } END { exit failures }';

#@ test whether project creates conflicting container image names.
test-image::
	@echo -e "$(IMAGE_NAMES)" | awk 'BEGIN{ RS="[[:space:]]"; FS="="; \
	  fmt = $(call amsg,error,image conflict [%s && %s => %s]\n) \
	} { if ($$1 in imgs) { failures++; \
	  printf(fmt, imgs[$$1], $$2, $$1) \
	} imgs[$$1] = $$2 } END { exit failures }';

# Function to test go versions.
test-go = \
	for VERSION in $(2); do \
	  if ! [[ "$(GOVERSION)" =~ ^$${VERSION}[0-9.]* ]]; then \
	    if [[ "$(GOVERSION)" < "$${VERSION}" ]]; then CHANGE="upgrade"; \
	    else CHANGE="downgrade"; fi; \
	    $(call emsg,warning,go version [$(1): $${VERSION} => $(GOVERSION)]: \
	      run 'make update-go $(GOVERSION)' to adjust the project \
	      or $${CHANGE} your go compiler to $${VERSION}!); \
	  fi; \
	done

#@ test whether project is using the latest go-version.
test-go::
	@if [ ! -f "go.mod" ];  then exit 0; fi; \
	VERSION="$$(grep "^go [0-9.]*$$" go.mod | cut -f2 -d' ')"; \
	$(call test-go,go.mod,"$${VERSION}"); \
	for FILE in $(DELIVERY); do \
	  if [ -f "$${FILE}" ]; then \
	    VERSION=($$(grep -Eo "$(DELIVERY_REGEX)" "$${FILE}" | \
	      grep -Eo "[0-9.]*" | sort --unique)); \
		$(call test-go,$${FILE},"$${VERSION[@]}"); \
	  fi; \
	done;

# process test arguments.
test-args = \
  if [ -n "$(1)" ]; then ARGS=($(1)); \
	if [[ "$${ARGS[0]}" =~ ^scope:([^[:space:]]*)$$ ]]; then \
	  if  [ "$${BASH_REMATCH[1]}" != "all" ]; then \
	    echo "-coverpgk=./$${ARGS[0]\#*:}"; \
	  else echo "-coverpkg=./..."; fi; \
	  ARGS=($${ARGS[@]:1}); \
	fi; \
    if [[ -f "$${ARGS[0]}" && ! -d "$${ARGS[0]}" && \
			 "$${ARGS[0]}" == *_test.go ]]; then \
	  find $$(dirname "$${ARGS[@]}" | sort --unique) \
		-maxdepth 1 -a -name "*.go" -a ! -name "*_test.go" \
		-o -name "common_test.go" -o -name "mock_*_test.go" | sed "s|^|./|"; \
	  echo $${ARGS[@]/\#/./}; \
	elif [[ -d "$${ARGS[0]}" && ! -f "$${ARGS[0]}" ]]; then \
	  echo $${ARGS[@]/\#/./}; \
	elif [[ ! -f "$${ARGS[0]}" && ! -d "$${ARGS[0]}" ]]; then \
	  for ARG in $${ARGS[0]}; do \
		if [ -z "$${PACKAGES}" ]; then PACKAGES="$${ARG%/*}"; \
		else PACKAGES="$${PACKAGES}\n$${ARG%/*}"; fi; \
		if [ -z "$${TEST_CASE}" ]; then TEST_CASES="-run $${ARG\#\#*/}"; \
		else TEST_CASES="$${TEST_CASES} -run $${ARG\#\#*/}"; fi; \
	  done; \
	  echo -en "$${PACKAGES}" | sort --unique | sed "s|^|./|"; \
	  echo "$${TEST_CASES}"; \
	else \
	  $(call emsg,warning,invalid test parameters [$${ARGS[@]}]); \
	fi; \
  else echo "./..."; fi

TEST_ARGS ?= $(shell $(call test-args,$(ARGS)))
TEST_DEPS ?=

# actuall targets for testing.
$(TEST_ALL):: $(SOURCES) init-code $(TEST_DEPS) $(DIR_BUILD)
	$(if $(filter %_test.go,$(SOURCES)), CGO_ENABLED=1 \
	$(GO) test $(TEST_FLAGS) -timeout $(TEST_TIMEOUT) \
	  -cover -coverprofile $@ $(TEST_ARGS);)
$(TEST_UNIT):: $(SOURCES) init-code $(DIR_BUILD)
	$(if $(filter %_test.go,$(SOURCES)), CGO_ENABLED=1 \
	$(GO) test $(TEST_FLAGS) -timeout $(TEST_TIMEOUT) \
	  -cover -coverprofile $@ -short $(TEST_ARGS);)
$(TEST_BENCH):: $(SOURCES) init-code $(DIR_BUILD)
	$(if $(filter %_test.go,$(SOURCES)), CGO_ENABLED=1 \
	$(GO) test $(TEST_FLAGS) -benchtime=$(TEST_TIMEOUT) \
	  -cover -coverprofile $@ -short -bench=. $(TEST_ARGS);)

#@ execute a kind of self-test running the main targets.
test-self::  clean-all all-clean clean-all install-all update-all? update-all
	@$(call emsg,success,test-self finished successfully!);


# disabled (deprecated): deadcode golint interfacer ifshort maligned musttag
#   nosnakecase rowserrcheck scopelint structcheck varcheck wastedassign
# diabled (distructive): nlreturn ireturn nonamedreturns varnamelen exhaustruct
#   exhaustivestruct gochecknoglobals gochecknoinits tagliatelle
# disabled (conflicting): godox gci paralleltest
# not listed (unnecessary): forcetypeassert wsl
# requires unknown setup: depguard
LINTERS_CUSTOM ?=
LINTERS_DISABLED ?=
LINTERS_DISCOURAGED ?= \
	exhaustruct gci gochecknoglobals gochecknoinits godox ireturn musttag \
	nlreturn nonamedreturns paralleltest rowserrcheck tagliatelle varnamelen \
	wastedassign
LINTERS_MINIMUM ?= \
	asasalint asciicheck bidichk bodyclose dogsled dupl dupword durationcheck \
	errchkjson funlen gocognit goconst gocyclo godot gofmt gofumpt goimports \
	gosimple govet importas ineffassign maintidx makezero misspell nestif \
	nilerr prealloc predeclared promlinter reassign sqlclosecheck staticcheck \
	typecheck unconvert unparam unused usestdlibvars whitespace
LINTERS_BASELINE ?= \
	containedctx contextcheck cyclop decorder errname forbidigo ginkgolinter \
	gocheckcompilerdirectives goheader gomodguard goprintffuncname gosec \
	grouper interfacebloat lll loggercheck nakedret nilnil noctx nolintlint \
	nosprintfhostport
LINTERS_EXPERT ?= \
	errcheck errorlint exhaustive gocritic err113 mnd gomoddirectives revive \
	stylecheck testableexamples testpackage thelper tparallel wrapcheck

LINT_FILTER := $(LINTERS_CUSTOM) $(LINTERS_DISABLED)
LINT_DISABLED ?= $(subst $(SPACE),$(COMMA),$(strip \
	$(filter-out $(LINT_FILTER),$(LINTERS_DISCOURAGED)) $(LINTERS_DISABLED)))
LINT_MINIMUM ?= $(subst $(SPACE),$(COMMA),$(strip \
	$(filter-out $(LINT_FILTER),$(LINTERS_MINIMUM)) $(LINTERS_CUSTOM)))
LINT_BASELINE ?= $(subst $(SPACE),$(COMMA),$(strip $(LINT_MINIMUM) \
	$(filter-out $(LINT_FILTER),$(LINTERS_BASELINE))))
LINT_EXPERT ?= $(subst $(SPACE),$(COMMA),$(strip $(LINT_BASELINE) \
	$(filter-out $(LINT_FILTER),$(LINTERS_EXPERT))))

ifeq ($(shell ls $(FILE_GOLANGCI) 2>/dev/null), $(FILE_GOLANGCI))
  LINT_CONFIG := --config "$(FILE_GOLANGCI)"
endif

LINT_MIN := --enable $(LINT_MINIMUM) --disable $(LINT_DISABLED)
LINT_BASE := --enable $(LINT_BASELINE) --disable $(LINT_DISABLED)
LINT_PLUS := --enable $(LINT_EXPERT) --disable $(LINT_DISABLED)
LINT_MAX := --enable-all --disable $(LINT_DISABLED)
LINT_ALL := --enable $(LINT_EXPERT),$(LINT_DISABLED) --disable-all

LINT_FLAGS ?= --allow-serial-runners --sort-results --color always
LINT_CMD ?= $(GOBIN)/golangci-lint run $(LINT_CONFIG) $(LINT_FLAGS)
LINT_CMD_CONFIG := $(MAKE) lint-config
ifeq ($(ARGS),linters)
  LINT_CMD := $(GOBIN)/golangci-lint linters $(LINT_CONFIG) $(LINT_FLAGS)
else ifeq ($(ARGS),config)
  LINT_CMD := @
  LINT_MIN := LINT_ENABLED=$(LINT_MINIMUM) \
    LINT_DISABLED=$(LINT_DISABLED) $(LINT_CMD_CONFIG)
  LINT_BASE := LINT_ENABLED=$(LINT_BASELINE) \
    LINT_DISABLED=$(LINT_DISABLED) $(LINT_CMD_CONFIG)
  LINT_PLUS := LINT_ENABLED=$(LINT_EXPERT) \
    LINT_DISABLED=$(LINT_DISABLED) $(LINT_CMD_CONFIG)
  LINT_MAX := LINT_DISABLED=$(LINT_DISABLED) $(LINT_CMD_CONFIG)
  LINT_ALL := LINT_ENABLED=$(LINT_EXPERT),$(LINT_DISABLED) $(LINT_CMD_CONFIG)
else ifeq ($(ARGS),fix)
  LINT_CMD := $(GOBIN)/golangci-lint run $(LINT_CONFIG) $(LINT_FLAGS) --fix
else ifneq ($(ARGS),)
  LINT_CMD := $(GOBIN)/golangci-lint run $(LINT_CONFIG) $(LINT_FLAGS)
  LINT_MIN := --disable-all --enable $(ARGS)
  LINT_BASE := --disable-all --enable $(ARGS)
  LINT_PLUS := --disable-all --enable $(ARGS)
  LINT_MAX := --disable-all --enable $(ARGS)
  LINT_ALL := --disable-all --enable $(ARGS)
endif
lint = @$(call emsg,info,linting [$(1)]); \
	echo "$(LINT_CMD) $(LINT_$(call upper,$(1)))"; \
	$(LINT_CMD) $(LINT_$(call upper,$(1)));

## Lint: targets to lint source code.

#@ <fix|linter> # execute all linters for the custom code quality level.
lint:: $(TARGETS_LINT)
#@ <fix|linter> # execute golangci linters for the custom code quality level.
lint-code:: lint-$(CODE_QUALITY)
#@ <fix|linter> # execute golangci linters for minimal code quality level (go-files).
lint-min:: init-code install-golangci-lint; $(if $(SOURCES),$(call lint,min))
#@ <fix|linter> # execute golangci linters for base code quality level (go-files).
lint-base:: init-code install-golangci-lint; $(if $(SOURCES),$(call lint,base))
#@ <fix|linter> # execute golangci linters for plus code quality level (go-files).
lint-plus:: init-code install-golangci-lint; $(if $(SOURCES),$(call lint,plus))
#@ <fix|linter> # execute golangci linters for maximal code quality level (go-files).
lint-max:: init-code install-golangci-lint; $(if $(SOURCES),$(call lint,max))
#@ <fix|linter> # execute all golangci linters for insane code quality level (go-files).
lint-all:: init-code install-golangci-lint; $(if $(SOURCES),$(call lint,all))

#@ create a golangci linter config using the custom code quality level.
lint-config::
	@LINT_START=$$(awk '($$0 ~ "^linters:.*"){print NR-1}' "$(FILE_GOLANGCI)"); \
	LINT_STOP=$$(awk '(start && $$0 ~ "^[^ ]+:$$"){print NR; start=0} \
	  ($$0 ~ "^linters:.*"){start=1}' "$(FILE_GOLANGCI)"); \
	(sed --silent '1,'$${LINT_START}'p' "$(FILE_GOLANGCI)"; \
	echo -e "linters:\n  enable:"; \
	for LINTER in "# List of min-set linters (min)" $(LINTERS_MINIMUM) \
		"# List of base-set linters (base)" $(LINTERS_BASELINE) \
		"# List of plus-set linters (plus)" $(LINTERS_EXPERT); do \
	  if [ "$${LINTER:0:1}" == "#" ]; then X=""; else X="- "; fi; \
	  echo -e "    $${X}$${LINTER}"; \
	done; echo -e "\n  disable:"; \
	for LINTER in "# List of to-avoid linters (avoid)" $(LINTERS_DISABLED); do \
	  if [ "$${LINTER:0:1}" == "#" ]; then X=""; else X="- "; fi; \
	  echo -e "    $${X}$${LINTER}"; \
	done; \
	echo; sed --silent $${LINT_STOP}',$$p' "$(FILE_GOLANGCI)") | \
	awk -v enabled=$${LINT_ENABLED} -v disabled=$${LINT_DISABLED} '$(awk-gensub) \
	  ((start == 2) && ($$1 == "-")) { \
	    enabled = enable[$$2]; disabled = disable[$$2]; \
	    if (enabled && disabled) { \
	      print $$0 "  # (conflicting)" \
	    } else if (!enabled && disabled) { \
	      print gensub("-","# -", 1) "  # (disabled)" \
	    } else if (!enabled && !disabled && enone) { \
	      print gensub("-","# -", 1) "  # (missing)" \
	    } else { print $$0 } \
	    enable[$$2] = 2; next \
	  } \
	  ((start == 3) && ($$1 == "-")) { \
	    enabled = enable[$$2]; disabled = disable[$$2]; \
	    if (enabled && disabled) { \
	      print gensub("-","# -", 1) "  # (conflicting)" \
	    } else if (enabled && !disabled) { \
	      print gensub("-","# -", 1) "  # (enabled)" \
	    } else if (!enabled && !disabled && dnone) { \
	      print gensub("-","# -", 1) "  # (missing)" \
	    } else { print $$0 } \
	    disable[$$2] = 2; next \
	  } \
	  ((start != 0) && ($$0 ~ "^[^ ]+:$$")) { start=0 } \
	  ((start >= 2) && ($$0 ~ "^  [^ ]+:$$")) { none=1; \
	    if (start == 2) { for (key in enable) { \
	      if (key && enable[key] == 1) { \
	        if (none) { print "    # Additional linters" } \
	        print "    - " key; none=0 \
	      } \
	    } } else if (start == 3) { for (key in disable) { \
	      if (key && disable[key] == 1) { \
	        if (none) { print "    # Additional linters" } \
	        print "    - " key; none=0 \
	      } \
	    } } \
	  } \
	  ((start != 0) && ($$0 == "  disable:")) { start = 3 }\
	  ((start != 0) && ($$0 == "  enable:")) { start = 2 } \
	  ((start == 0) && ($$0 == "linters:")) { start = 1; \
	    enone = split(enabled, array, ","); \
		for (i in array){ enable[array[i]] = 1 } \
	    dnone = split(disabled, array, ","); \
		for (i in array){ disable[array[i]] = 1 } \
	  } { print $$0 }';

#@ execute all codacy linters activated by the custom setup (all files).
lint-codacy:: lint-revive $(TARGETS_LINT_CODACY_CLIENTS) $(TARGETS_LINT_CODACY_BINARIES)
$(TARGETS_LINT_CODACY_CLIENTS):: lint-%: init-code init-analysis-cli init-jre
	@$(call emsg,info,linting [$*]); \
	LARGS=("--skip-uncommitted-files-check"); \
	if [ "$(ARGS)" == "verbose" ]; then LARGS+=("--verbose"); fi; \
	LARGS+=("--codacy-api-base-url" "$(CODACY_API_BASE_URL)"); \
	if [ -n "$(CODACY_PROJECT_TOKEN)" ]; then \
	  LARGS+=("--upload" "--verbose"); \
	  LARGS+=("--project-token=$(CODACY_PROJECT_TOKEN)"); \
	elif [ -n "$(CODACY_API_TOKEN)" ]; then \
	  LARGS+=("--upload" "--verbose"); \
	  LARGS+=("--provider=$(CODACY_PROVIDER)"); \
	  LARGS+=("--username=$(CODACY_USER)"); \
	  LARGS+=("--project=$(CODACY_PROJECT)"); \
	  LARGS+=("--api-token=$(CODACY_API_TOKEN)"); \
	fi; \
	CMD=("$(JRE_HOME)/bin/java" \
	  -jar "$(GOBIN)/codacy-analysis-cli-$(CODACY_ANALYSIS-CLI_VERSION)" \
	  analyze "$${LARGS[@]}" --tool $*); \
	echo "$${CMD[@]}"; "$${CMD[@]}" || $(CODACY_CONTINUE);

LINT_ARGS_GOSEC_LOCAL := -log /dev/null -exclude G307 ./...
LINT_ARGS_GOSEC_UPLOAD := -log /dev/null -exclude G307 -fmt json ./...
LINT_ARGS_STATICCHECK_LOCAL := -tests ./...
LINT_ARGS_STATICCHECK_UPLOAD := -tests -f json ./...

$(TARGETS_LINT_CODACY_BINARIES):: lint-%: init-code init-% install-%
	@$(call emsg,info,linting [$*]); COMMIT=$$($(GITHASH)); \
	VERSION="$(CODACY_$(call upper,$*)_VERSION)"; \
	LARGS=("--silent" "--location" "--request" "POST" \
	  "--header" "Content-type: application/json"); \
	if [ -n "$(CODACY_PROJECT_TOKEN)" ]; then \
	  BASE="$(CODACY_API_BASE_URL)/2.0/commit/$${COMMIT}"; \
	  LARGS+=("-H" "project-token: $(CODACY_PROJECT_TOKEN)"); \
	elif [ -n "$(CODACY_API_TOKEN)" ]; then \
	  SPATH="$(CODACY_PROVIDER)/$(CODACY_USER)/$(CODACY_PROJECT)"; \
	  BASE="$(CODACY_API_BASE_URL)/2.0/$${SPATH}/commit/$${COMMIT}"; \
	  LARGS+=("-H" "api-token: $(CODACY_API_TOKEN)"); \
	fi; \
	if [ -n "$${BASE}" ]; then \
	  echo -e """$(GOBIN)/$* $(LINT_ARGS_$(call upper,$*)_UPLOAD) | \
	    $(GOBIN)/codacy-$*-$${VERSION} | \
	    curl "$${LARGS[@]}" --data @- "$${BASE}/issuesRemoteResults"; \
	    curl "$${LARGS[@]}" "$${BASE}/resultsFinal""""; \
	  ( $(GOBIN)/$* $(LINT_ARGS_$(call upper,$*)_UPLOAD) | \
	    $(GOBIN)/codacy-$*-$${VERSION} | \
	    curl "$${LARGS[@]}" --data @- "$${BASE}/issuesRemoteResults"; echo; \
	    curl "$${LARGS[@]}" "$${BASE}/resultsFinal"; echo ) || $(CODACY_CONTINUE); \
	else \
	  echo $(GOBIN)/$* $(LINT_ARGS_$(call upper,$*)_LOCAL); \
	  $(GOBIN)/$* $(LINT_ARGS_$(call upper,$*)_LOCAL) || $(CODACY_CONTINUE); \
	fi;

#@ execute revive linter (go-files).
lint-revive:: init-code install-revive
	@$(call emsg,info,linting [revive]);
	revive -formatter friendly -config="$(FILE_REVIVE)" $(SOURCES) || $(CODACY_CONTINUE);

#@ execute markdown linter (md-files).
lint-markdown:: init-code $(GOBIN)/markdownlint
	@mapfile -t FILES < <($(call find-all,.,-name "*.md")); \
	if [ "$${#FILES[@]}" != "0" ]; then \
	  $(call emsg,info,linting [markdown]); \
	  echo "markdownlint --config .markdownlint.yaml $${FILES[@]}"; \
	  if command -v markdownlint &> /dev/null; then \
	    markdownlint --config .markdownlint.yaml "$${FILES[@]}"; \
	  elif [ -n "$(IMAGE_CMD)" ]; then \
	    $(IMAGE_CMD) run --tty --volume=$${PWD}:/src:ro \
	      container-registry.zalando.net/library/node-18-alpine:latest \
	      /bin/sh -c "npm install --global markdownlint-cli >/dev/null 2>&1 && \
	        cd /src && ls -la && markdownlint --config .markdownlint.yaml ."; \
	  else $(call emsg,warning,linting [markdown] - command not found!); fi; \
	fi;

#@ execute shellcheck to find potential shell script issues (sh-files).
lint-shell:: init-code
	@mapfile -t FILES < <($(call find-all,.,-name "*.sh")); \
	if  [ -n "$${FILES}" ]; then \
	  $(call emsg,info,linting [shell]); \
	  ARGS=("--color=always" "--external-sources"); \
	  if [ -n "$(ARGS)" ]; then ARGS+=($(ARGS)); fi; \
	  echo "shellcheck $${ARGS[@]} $${FILES[@]}"; \
	  if command -v shellcheck &> /dev/null; then \
	    shellcheck "$${ARGS[@]}" "$${FILES[@]}"; \
	  elif [ -n "$(IMAGE_CMD)" ]; then \
	    $(IMAGE_CMD) run --rm --volume="$${PWD}:/mnt" --network host \
	      koalaman/shellcheck:stable "$${ARGS[@]}" "$${FILES[@]}"; \
	  else $(call emsg,warning, linting [shell] - command not found!); fi; \
	fi;

#@ execute gitleaks to check committed code for leaking secrets (all files).
lint-leaks:: install-gitleaks
	@if [ -d "$(DIR_GIT)" ]; then $(call emsg,info,linting [leaks]); \
	  echo "gitleaks detect --no-banner --verbose --source ."; \
	  gitleaks detect --no-banner --verbose --source .; \
	fi;
#@ execute gitleaks to check un-committed code changes for leaking secrets (all files).
lint-leaks?:: install-gitleaks
	@if [ -d "$(DIR_GIT)" ]; then $(call emsg,info,linting [leaks?]); \
	  echo "gitleaks protect --no-banner --verbose --source ."; \
	  gitleaks protect --no-banner --verbose --source .; \
	fi;
#@ execute govulncheck to find vulnerabilities in dependencies (go-files).
lint-vuln:: install-govulncheck
	govulncheck -test ./...
#@ <top #|over #|avg> <pkg> # execute go(cyclo|cognit) linter (go-files).
lint-gocyclo lint-gocognit:: lint-%: install-%
	@$(call emsg,info,linting [gocyclo]); ARGS=($(ARGS)); MODS="0"; \
	while [ "$${#ARGS[@]}" != "0" ]; do \
	  if [ "$${ARGS[0]}" == "top" ]; then ARGS+=(-$${ARGS[0]}); MODS="1"; \
	  elif [ "$${ARGS[0]}" == "over" ]; then ARGS+=(-$${ARGS[0]}); MODS="1"; \
	  elif [ "$${ARGS[0]}" == "avg" ]; then ARGS+=(-$${ARGS[0]}); MODS="0"; \
	  else ARGS+=($${ARGS[0]}); MODS=$$((MODS-1)); fi; \
	  ARGS=("$${ARGS[@]:1}"); \
	done; \
	if [[ "$${MODS}" == "0" ]]; then ARGS+=($(MODULES)); fi; \
	$* "$${ARGS[@]}";


TOKEN_REPLACE := --token=*/--token=...secret...
#@ execute zally api-linter to find API issues (yaml-files).
lint-apis:: install-zally
	@if [ -z "$(filter %.yaml,$(ARGS))" ]; then \
	   mapfile -t FILES < <($(call find-all,zalando-apis,-name "*.yaml")); \
	else mapfile -t FILES < <(echo $(filter %.yaml,$(ARGS))); fi; \
	if [ -n "$(ZALLY_URL)" ] && [ -n "$(ZALLY_TOKEN)" ] && \
	   [ -n "$${FILES[@]}" ]; then $(call emsg,info,linting [apis]); \
	  if ! curl --silent "$(ZALLY_URL)"; then \
	    $(call emsg,warning,API linter not available [$(ZALLY_URL)]); exit 0; \
	  fi; ARGS=("--linter-service=$(ZALLY_URL)"); \
	  if command -v ztoken > /dev/null; then ARGS+=("--token=$(ZALLY_TOKEN)"); fi; \
	  for APISPEC in $${FILES}; do \
	    echo "zally "$${ARGS[@]/$(TOKEN_REPLACE)}" lint \"$${APISPEC}\""; \
	    zally "$${ARGS[@]}" lint "$${APISPEC}" || exit 1; \
	  done; \
	fi;


# Variables for setting up container specific build flags.
BUILD_OS ?= $(shell $(GO) env GOOS)
BUILD_ARCH ?= $(shell $(GO) env GOARCH)

# Function to select right main package of command.
main-pkg = $(patsubst $(1)=%,%,$(firstword $(filter $(1)=%,$(COMMANDS_PKG))))

# Functions and variables to propagate versions to build commands.
LD_CONFIG_PATHS ?= main # $(shell $(GO) list ./... | grep "config$$")
ld-flag = $(addprefix -X ,$(addsuffix .$(1),$(LD_CONFIG_PATHS)))
ld-flags = $(call ld-flag,Version=$(BUILD_VERSION)) \
	$(call ld-flag,Revision=$(shell $(GIT) rev-parse HEAD)) \
	$(call ld-flag,Build=$(shell date --iso-8601=seconds)) \
	$(call ld-flag,Commit=$(shell $(GIT) log -1 --date=iso8601-strict --format=%cd)) \
	$(call ld-flag,Dirty=$(shell $(GIT) diff --quiet && echo false || echo true)) \
	$(call ld-flag,Path=$(GITURL)$(patsubst .%,%,$(1))) \
	$(call ld-flag,GitHash=$(shell $(GIT) rev-parse --short HEAD))


## Build: targets to build native and linux platform executables.

#@ build default executables (native).
build:: build-native
#@ build native platform executables using system architecture.
build-native:: $(TARGETS_BUILD)
$(TARGETS_BUILD):: build-%: $(DIR_BUILD)/%
$(DIR_BUILD)/%:: test-build init-code $(SOURCES) $(DIR_BUILD)
	$(strip GOOS=$(BUILD_OS) GOARCH=$(BUILD_ARCH) CGO_ENABLED=1 $(GO) build \
	  -ldflags="$(call ld-flags,$(call main-pkg,$*)) $(LD_FLAGS)" \
	  $(BUILD_FLAGS) -race -o $@ $(call main-pkg,$*)/main.go);

#@ build linux platform executables using default (system) architecture.
build-linux:: test-build init-code $(TARGETS_BUILD_LINUX)
$(DIR_BUILD)/linux/%:: $(call main-pkg,%) init-code $(SOURCES) $(DIR_BUILD)
	$(strip GOOS=linux GOARCH=$(BUILD_ARCH) CGO_ENABLED=0 $(GO) build \
	  -ldflags="$(call ld-flags,$(call main-pkg,$*)) $(LD_FLAGS_LINUX)" \
	  $(BUILD_FLAGS) -o $@ $(call main-pkg,$*)/main.go);

#@ build container image (alias for image-build).
build-image:: image-build

## Image: targets to build and push container images.

#@ build and push container images - if setup.
image:: $(if $(filter $(IMAGE_PUSH),never),,image-push)
#@ build container images.
image-build:: test-image $(TARGETS_IMAGE_BUILD)

# Setup custom image build target dependencies.
$(foreach line,$(shell $(call image-build-deps,$(IMAGE_NAMES))),$(eval $(line)))
# Setup custom image build targets.
$(TARGETS_IMAGE_BUILD):: image-build/%: build-linux
	@FILE="$*"; IMAGE="$$($(call image-name,$*))"; \
	if [ "$(IMAGE_PUSH)" == "never" ]; then $(call emsg,info, \
	  aborting - we never build images [$${IMAGE}]); exit 0; \
	elif [ -z "$(IMAGE_CMD)" ]; then $(call emsg,warning, \
	  continuing - no docker command [$${IMAGE}]!); exit 0; \
	fi; \
	REVISION="$$($(GIT) rev-parse HEAD 2>/dev/null)"; \
	BASE="$$(grep "^FROM[[:space:]]" "$${FILE}" | tail -n1 | cut -d" " -f2)"; \
	$(call emsg,info,building image [$${IMAGE}] from [$${FILE}]); \
	$(IMAGE_CMD) build --tag "$${IMAGE}" --file="$${FILE}" . \
	  --label=org.opencontainers.image.created="$$(date --rfc-3339=seconds)" \
	  --label=org.opencontainers.image.vendor="zalando/$(TEAM)" \
	  --label=org.opencontainers.image.source="$(GITURL)" \
	  --label=org.opencontainers.image.version="$${IMAGE##*:}" \
	  --label=org.opencontainers.image.revision="$${REVISION}" \
	  --label=org.opencontainers.image.base.name="$${BASE}" \
	  --label=org.opencontainers.image.ref.name="$${IMAGE}"; \
	$(IMAGE_CMD) tag "$${IMAGE}" "$${IMAGE%%:*}:latest";

#@ push contianer images - if setup and allowed.
image-push:: test-image $(TARGETS_IMAGE_PUSH)
$(TARGETS_IMAGE_PUSH):: image-push/%: image-build/%
	@IMAGE="$$($(call image-name,$*))"; VERSION="$${IMAGE##*:}"; \
	if [ "$(IMAGE_PUSH)" == "never" ]; then $(call emsg,info, \
	  aborting - we never push images [$${IMAGE}]); exit 0; \
	elif [ "$${VERSION}" == "latest" ]; then $(call emsg,info, \
	  aborting - we never push latest images [$${IMAGE}]); exit 0; \
	elif [[ "$${VERSION}" =~ ^pr-.*$$ ]] && \
	    [ "$(IMAGE_PUSH)" != "pulls" ]; then $(call emsg,info, \
	  aborting - we never push pull request images [$${IMAGE}]); exit 0; \
	elif [ -z "$(IMAGE_CMD)" ]; then $(call emsg,warning, \
	  continuing - no docker command [$${IMAGE}]!); exit 0; \
	fi; \
	$(IMAGE_CMD) push "$${IMAGE}";


## Install: targets to (un-)install software and tools.

#@ install all software created by the project.
install:: $(TARGETS_INSTALL)
#@ install all software created and used by the project.
install-all:: $(TARGETS_INSTALL_ALL)
#@ install-*: install the matched software command or service.

# install go tools used by the project.
$(TARGETS_INSTALL_GO):: install-%: $(GOBIN)/%
	@$(call go-check-version,$*,$(ARGS));
$(addprefix $(GOBIN)/,$(COMMANDS_GO)): $(GOBIN)/%: $(GOBIN)
	@$(call go-install-module,$*,$(ARGS));
# install go tools providing an install.sh script.
$(TARGETS_INSTALL_SH):: install-%: $(GOBIN)/%
$(addprefix $(GOBIN)/,$(COMMANDS_SH)): $(GOBIN)/%: $(GOBIN)
	@if ! command -v $*; then \
	  curl --silent --show-error --fail --location \
	    https://raw.githubusercontent.com/anchore/$*/main/install.sh | \
	    sh -s -- -b $(GOBIN); \
	fi;
# install npm tools used by the project.
$(TARGETS_INSTALL_NPM):: install-%: $(GOBIN)/%
$(addprefix $(GOBIN)/,$(TOOLS_NPM:-cli=)): $(GOBIN)/%:
	@CMD="$(filter $*-cli,$(TOOLS_NPM))"; \
	if command -v npm >/dev/null 2>&1 && ! command -v $*; then \
	  echo "npm install --global $${CMD}"; \
	  npm install --global "$${CMD}"; \
	fi;

#@ install software command or service created by the project.
$(TARGETS_INSTALL):: install-%: $(GOBIN)/%
$(addprefix $(GOBIN)/,$(COMMANDS)): $(GOBIN)/%: $(DIR_BUILD)/%
	cp -f "$<" "$(GOBIN)/$*";

#@ uninstall all software created by the project.
uninstall:: $(TARGETS_UNINSTALL)
#@ uninstall all software created and used by the projct.
uninstall-all:: $(TARGETS_UNINSTALL_ALL)
#@ uninstall-*: uninstall the matched software command or service.

# uninstall go tools used by the project.
$(TARGETS_UNINSTALL_GO):: uninstall-%:
	@rm --verbose --force $(wildcard $(GOBIN)/$*);
# uninstall tools providing an install.sh tool.
$(TARGETS_UNINSTALL_SH):: uninstall-%:
	@rm --verbose --force $(wildcard $(GOBIN)/$*);
# uninstall npm based tools used by the project.
$(TARGETS_UNINSTALL_NPM):: uninstall-%:
	@CMD="$(filter $*-cli,$(TOOLS_NPM))"; \
	if command -v npm >/dev/null 2>&1; then \
	  echo "npm uninstall --global $${CMD}"; \
	  npm uninstall --global "$${CMD}"; \
	fi;
# uninstall codacy tools used by the project.
$(TARGETS_UNINSTALL_CODACY):: uninstall-codacy-%:
	@VERSION="$(CODACY_$(call upper,$*)_VERSION)"; \
	rm --verbose --force $(wildcard $(GOBIN)/codacy-$*-$${VERSION});
# uninstall software command or service created by the project.
$(TARGETS_UNINSTALL):: uninstall-%:
	@rm --verbose --force $(wildcard $(GOBIN)/$*);


## Release: targets to support release process.
version-bump = \
	$$(awk -v arg="$(1)" '{ \
	  op["major"] = 1; op["minor"] = 2; op["patch"] = 3; \
	  if (arg ~ "^[0-9]") { printf("%s", arg); exit 0; \
	  } else if ((pos = op[substr(arg,1,5)]) == 0) { \
	    if (length(arg) <= 3) { pos = 4 - length(arg) }; \
	  } else { arg = substr(arg,6); } \
	  patsplit($$0, v, "[0-9-]*", seps); len = length(seps); \
	  while (len <= 3) { seps[len-1] = "."; len++ }; \
	  if (arg !~ "-$$") { v[pos]++ } else { v[pos]-- }; \
	  for (i = 1; i < len; i++) { \
	    printf("%01d%s", (i <= pos) ? v[i] : 0, seps[i]) \
	  } \
	}' "$(2)")

#@ <version|major|minor|patch>[+-]{}? # update version and prepare release of the software.
version-bump::
	@if [ -z "$(ARGS)" ]; then ARGS="patch"; else ARGS="$(ARGS)"; fi; \
	if [ ! -e VERSION ]; then echo "0.0.0" >VERSION; fi; \
	if [[ "$${ARGS}" =~ ^(major|minor|patch|)[+-]*$$ ]]; then \
	  VERSION="$(call version-bump,$${ARGS},VERSION)"; \
	elif ! [[ "$${ARGS}" =~ ^[0-9]+(\.[0-9]+){0,2}(-.*)?$$ ]]; then \
	  echo "error: invalid new version [$${ARGS}]"; exit 1; \
	else VERSION="$${ARGS}"; fi; echo $${VERSION} >VERSION; \
	$(call emsg,success, bumped version [$${VERSION}]);


#@ <version> # release a fixed version of the software as library.
version-release::
	@if [ -f VERSION ]; then VERSION="$$(cat VERSION)"; fi; \
	if [[ "$(ARGS)" =~ ^[0-9]+(\.[0-9]+){0,2}(-.*)?$$ ]]; then \
	  VERSION="$(ARGS)"; \
	fi; $(GIT) fetch --verbose --tags; \
	if [ -n "$${VERSION}" -a -z "$$($(GIT) tag --list "v$${VERSION}")" ]; then \
	  ( $(GIT) gh-release "v$${VERSION}" ) || ( \
	    $(GIT) config user.name "$$($(GIT) log -n 1 --pretty=format:%an)" && \
	    $(GIT) config user.email "$$($(GIT) log -n 1 --pretty=format:%ae)" && \
	    $(GIT) tag --message "tag: new version $${VERSION}" "v$${VERSION}" && \
	    $(GIT) push --follow-tags --verbose origin "v$${VERSION}" \
	  ) && $(call emsg,success, releasing version [v$${VERSION}]) || \
	  $(call emsg,failure, releasing version [v$${VERSION}]); \
	fi;

#@ publish the current version by enforcing a registry lookup (experimental).
version-publish:: $(TARGETS_PUBLISH)
$(TARGETS_PUBLISH): version-publish-%:
	@if [ "$*" != "all" ]; then \
	  if [ -f "cmd/$*/main.go" ]; then CMD="/cmd/$*"; else exit 0; fi; \
	fi; \
	if [ -f VERSION ]; then VERSION="$$(cat VERSION)"; else \
	  VERSION="$$(TZ=UTC0 $(GIT) show --quiet --date='format-local:%Y%m%d%H%M%S' \
	    --format="0.0.0-%cd-%H" | cut -c -33)"; \
	fi; \
	TARGET="$(GITURL)$${CMD}@v$${VERSION}"; \
	if [ "$(GITHOST)" == "github.com" ]; then \
	  if [ -z "$${CMD}" ]; then \
	    $(call emsg,info,publishing via curl [$${TARGET}]); \
	    curl  --silent --show-error --fail --location \
	      https://sum.golang.org/lookup/$${TARGET} && \
	    $(call emsg,success,publishing via curl [$${TARGET}]) || \
	    $(call emsg,failure,publishing via curl [$${TARGET}]); \
	  fi; \
	  if [ -f ".$${CMD}/main.go" ]; then \
	    $(call emsg,info,publishing go install [$${TARGET}]); \
	    $(GO) install $(INSTALL_FLAGS) $${TARGET}; \
	    $(call emsg,success,publishing go install [$${TARGET}]) || \
	    $(call emsg,failure,publishing go install [$${TARGET}]); \
	  fi; \
	fi;


## Run: targets for starting services and commands for testing.
HOST := "127.0.0.1"
RUN_DEPS ?=

#@ start a postgres database instance for testing.
run-db:: $(DIR_RUN)
	@if ! [[ " $(TEST_DEPS) $(RUN_DEPS) " =~ " run-db " ]]; then exit 0; fi; \
	$(call emsg,info,ensure $(DB_IMAGE) running on $(HOST):$(DB_PORT)); \
	if [ -z "$(IMAGE_CMD)" ]; then $(call emsg,warning, \
	  continuing - no docker command [postgres]!); exit 0; fi; \
	if [ -n "$$($(IMAGE_CMD) ps | grep "$(DB_IMAGE).*$(HOST):$(DB_PORT)")" ]; then \
	  $(call emsg,info,port allocated - using existing [postgres]); exit 0; fi; \
	$(IMAGE_CMD) start $(GITNAME)-db 2>/dev/null || ( \
	$(IMAGE_CMD) run --detach --tty --name $(GITNAME)-db \
	  --network host --publish $(HOST):$(DB_PORT):5432 \
	  --env POSTGRES_USER="$(DB_USER)" \
	  --env POSTGRES_PASSWORD="$(DB_PASSWORD)" \
	  --env POSTGRES_DB="$(DB_NAME)" $(DB_IMAGE) \
	    -c 'shared_preload_libraries=pg_stat_statements' \
        -c 'pg_stat_statements.max=10000' \
        -c 'pg_stat_statements.track=all' \
	  $(ARGS) 2>&1 & \
	until [ "$$($(IMAGE_CMD) inspect --format {{.State.Running}} \
	  $(GITNAME)-db 2>/dev/null)" == "true" ]; \
	do $(call emsg,info,waiting for db container); sleep 1; done && \
	until $(IMAGE_CMD) exec $(GITNAME)-db \
	  pg_isready -h localhost -U $(DB_USER) -d $(DB_NAME); \
	do $(call emsg,info,waiting for db service); sleep 1; done) | \
	tee -a $(DIR_RUN)/$(GITNAME)-db;

#@ start an AWS localstack instance for testing.
run-aws:: $(DIR_RUN)
	@if ! [[ " $(TEST_DEPS) $(RUN_DEPS) " =~ " run-aws " ]]; then exit 0; fi; \
	$(call emsg,info,ensuring $(AWS_IMAGE) is running on $(HOST):4566/4571) && \
	if [ -z "$(IMAGE_CMD)" ]; then $(call emsg,warning, \
	  continuing - no docker command [aws/localstack]!); exit 0; \
	elif [ -n "$$($(IMAGE_CMD) ps | \
	    grep "$(AWS_IMAGE).*$(HOST):4566.*$(HOST):4571")" ]; then \
	  $(call emsg,info,ports allocated - using existing [aws/localstack]); \
	  $(call run-setup-aws) || exit 1 && exit 0 ; \
	fi; \
	$(IMAGE_CMD) start $(GITNAME)-aws 2>/dev/null || ( \
	$(IMAGE_CMD) run --detach --tty --name $(GITNAME)-aws \
	  --network host --publish $(HOST):4566:4566 --publish $(HOST):4571:4571 \
	  --env SERVICES="$(AWS_SERVICES)" $(AWS_IMAGE) $(ARGS) 2>&1 && \
	until [ "$$($(IMAGE_CMD) inspect --format {{.State.Running}} \
	  $(GITNAME)-aws 2>/dev/null)" == "true" ]; \
	do $(call emsg,info,waiting for aws container); sleep 1; done && \
	until $(IMAGE_CMD) exec $(GITNAME)-aws \
	  curl --silent http://$(HOST):4566; \
	do $(call emsg,info,waiting for aws service); sleep 1; done && \
	$(call run-setup-aws) || exit 1) | \
	tee -a $(DIR_RUN)/$(GITNAME)-aws.log;

#@ run-*: start the matched command using the native binary.
$(TARGETS_RUN):: run-%: $(DIR_BUILD)/% $(RUN_DEPS) $(DIR_RUN) $(DIR_CRED)
	@$(call run-setup) && $(call run-vars,) $(call run-vars-local,) \
	  $(DIR_BUILD)/$* $(ARGS) 2>&1 | \
	  tee -a $(DIR_RUN)/$(GITNAME)-$*.log; \
	exit $${PIPESTATUS[0]};

#@ run-go-*: start the matched command using go run.
$(TARGETS_RUN_GO):: run-go-%: $(DIR_BUILD)/% $(RUN_DEPS) $(DIR_RUN) $(DIR_CRED)
	@$(call run-setup) && $(call run-vars,) $(call run-vars-local,) \
	  $(GO) run cmd/$*/main.go $(ARGS) 2>&1 | \
	  tee -a $(DIR_RUN)/$(GITNAME)-$*.log; \
	exit $${PIPESTATUS[0]};

#@ run-image-*: start the matched command via the container images.
$(TARGETS_RUN_IMAGE):: run-image-%: $(RUN_DEPS) $(DIR_RUN) $(DIR_CRED)
	@NAME="$(GITNAME)-$*"; \
	$(call emsg,info,running image [$${NAME}]); \
	if [ -z "$(IMAGE_CMD)" ]; then $(call emsg,error, \
		aborting - no docker command [$${NAME}]!); exit 1; fi; \
	trap "$(IMAGE_CMD) rm $${NAME} >/dev/null" EXIT; \
	trap "$(IMAGE_CMD) kill $${NAME} >/dev/null" INT TERM; \
	if [ -n "$(filter %$*,$(IMAGE_FILES))" ]; then \
	  IMAGE="$$(echo "$(IMAGE)" | sed "s/:/-$*:/")"; \
	else IMAGE="$(IMAGE)"; fi && if tty -s; then TTY=" --tty"; fi && \
	$(call run-setup) && $(IMAGE_CMD) run$${TTY} --name $${NAME} \
	  --volume $(DIR_CRED):/meta/credentials --volume $(DIR_RUN)/temp:/tmp \
	  --network=host $(call run-vars,--env) $(call run-vars-image,--env) \
	  ${IMAGE} /$* $(ARGS) 2>&1 | \
	tee -a $(DIR_RUN)/$${NAME}.log; exit $${PIPESTATUS[0]};

#@ clean up all running container images.
run-clean:: $(TARGETS_RUN_CLEAN)
#@ run-clean-*: kill and remove the container image of the matched command.
$(TARGETS_RUN_CLEAN):: run-clean-%:
	@NAME="$(GITNAME)-$*"; \
	$(call emsg,info,cleaning container [$${NAME}]); \
	if [ -z "$(IMAGE_CMD)" ]; then $(call emsg,warning,\
	  aborting - no docker command [$${NAME}]!); exit 0; fi; \
	if [ -n "$$($(IMAGE_CMD) ps | grep "$${NAME}")" ]; then \
	  $(IMAGE_CMD) kill $${NAME} > /dev/null && \
	  $(call emsg,success,killed container [$${NAME}]); \
	fi; \
	if [ -n "$$($(IMAGE_CMD) ps -a | grep "$${NAME}")" ]; then \
	  $(IMAGE_CMD) rm $${NAME} > /dev/null && \
	  $(call emsg,success,removed container [$${NAME}]); \
	fi;


## Cleanup: targets to clean up sources, tools, and containers.

#@ clean up resources created during build processes.
clean:: $(TARGETS_CLEAN)
#@ clean up all resources, i.e. also tools installed for the build.
clean-all:: $(TARGETS_CLEAN_ALL)
#@ clean up all resources created by initialization.
clean-init:: clean-hooks
#@ clean up all hooks created by initialization.
clean-hooks::
	@rm --verbose --force $(DIR_GIT)/hooks/pre-commit;
	@rm --verbose --force $(DIR_GIT)/hooks/commit-msg;
#@ clean up all resources created by building and testing.
clean-build::
	@rm --verbose --force --recursive $(DIR_BUILD) $(DIR_RUN) $(GEN_DIRS); \
	$(call clean-file,.,-name "mock_*_test.go" -o -name "zz_generated.*.go");
#@ clean up all package dependencies by removing packages.
clean-deps::
	for PACKAGE in $$(cat go.sum | cut -d ' ' -f 1 | sort --unique); do \
	  $(GO) get $${PACKAGE}@none; \
	done;
#@ clean up all running container images.
clean-run:: $(TARGETS_CLEAN_RUN)
#@ clean-run-*: clean up matched running container image.
$(TARGETS_CLEAN_RUN):: clean-run-%: run-clean-%


## Update: targets to update tools, configs, and dependencies.

#@ update default or customized update targets.
update:: $(TARGETS_UPDATE)
#@ check default or customized update targets for updates.
update?:: $(TARGETS_UPDATE?)
#@ update all components.
update-all:: $(TARGETS_UPDATE_ALL)
#@ check all components for udpdates.
update-all?:: $(TARGETS_UPDATE_ALL?)

# Function to determine the latest go version.
update-go-latest = \
	$$(ARCH="$$($(GO) env GOOS)-$$($(GO) env GOARCH)" && \
	  curl --silent --header "Accept-Encoding: gzip" "https://go.dev/dl/" | \
	    gunzip | grep -o "go[0-9.]*$${ARCH}\.tar\.gz" | head -n 1 | \
	    sed "s/go\(.*\)\.$${ARCH}\.tar\.gz/\1/")

#@ <version> # update go to given, current, or latest version.
update-go::
	@if [ ! -f "go.mod" ]; then exit 0; fi; \
	if [ "$(ARGS)" == "latest" ]; then VERSION="$(update-go-latest)"; \
	elif [[ "$(ARGS)" =~ ^[0-9.]+$$ ]]; then VERSION="$(ARGS)"; \
	else VERSION="$(GOVERSION)"; fi; \
	$(call emsg,info,updating golang version [$${VERSION}]); \
	if ! [[ "$(GOVERSION)" =~ ^$${VERSION}[0-9.]*$$ ]]; then \
	  $(call emsg,warning,current compiler differs \
	    [$(GOVERSION) => $${VERSION}]); \
	fi; \
	if ! [[ "$(GOVERSION)" < "1.21" ]]; then \
	  $(GO) mod tidy -go=$${VERSION}; $(GO) get go@$${VERSION}; \
	  sed --regexp-extended --in-place --expression="/^toolchain.*$$/d;" go.mod; \
	fi; \
	if [[ "$${VERSION}" < "1.21" ]]; then \
	  sed --regexp-extended --in-place \
	    --expression="s/$(GOMOD_REGEX)/\1$${VERSION%\.*}/;" go.mod; \
	  $(GO) mod tidy -go=$${VERSION%\.*}; \
	fi; \
	if [ "$${VERSION}" != "$(ARGS)" ]; then VERSION="$${VERSION%\.*}"; fi; \
	for FILE in $(DELIVERY); do \
	  if [ -f "$${FILE}" ]; then \
	    sed --regexp-extended --in-place \
		  --expression="s/$(DELIVERY_REGEX)/\1$${VERSION}/" "$${FILE}"; \
	  fi; \
	done;

#@ check whether a new latest go version exists.
update-go?::
	@VERSION="$(update-go-latest)"; \
	if ! [ "$${VERSION}" == "$(GOVERSION)" ]; then \
	  $(call emsg,warning,new golang version available [$${VERSION}]: \
	    run 'make update-go latest' to update the project!); \
	fi;

# Functions to create the list of updates (not sure whether go list is contributing).
update-args = \
	if [[ " $(1) " =~ " major " ]]; then ARGS="-cached=false -major"; \
	elif [[ " $(1) " =~ " pre " ]]; then ARGS="-cached=false -pre"; \
	else ARGS="-cached=false"; fi
update-list = \
	( gomajor list $(1) 2>/dev/null | sed "s/://1; s/\[latest /\[/g"; \
	  $(GO) list -m -u -mod=mod $(2) | grep "\[.*\]$$" \
	) | sort --unique | sed "s/\]//g; s/\[/=> /"
update-config = \
	if [ "$(gomake-version)" != "(devel)" ] && [ "$(1)" != "current" ]; then \
	  GOMAKE="github.com/tkrop/go-make"; \
	  if [ -n "$(1)" ]; then GOMAKE="$${GOMAKE}@$(1)"; else \
	    GOMAKE="$$($(call go-pkg-latest,$${GOMAKE}))"; \
	  fi; CONFIG="$(GOPATH)/pkg/mod/$${GOMAKE}/config"; \
	  $(call go-install,go-make,$${GOMAKE}); \
	else CONFIG="$(GOMAKE_CONFIG)"; fi

# TODO: check how to utilize: 'go list -m -u -mod=mod all' in 'update-deps'.

#@ [major|pre|minor] # update minor (and major) dependencies to latest versions.
update-deps:: test-go update/go.mod
update/go.mod:: install-gomajor
	@if [ ! -f "go.mod" ]; then exit 0; fi; \
	if [ -n "$(ARGS)" ]; then $(call update-args,$(ARGS)); \
	  if [[ " $(ARGS) " =~ " minor " ]]; then PACKAGES="all"; fi; \
	  readarray -t UPDATES < <($(call update-list,$${ARGS},$${PACKAGES})); \
	  for UPDATE in "$${UPDATES[@]}"; do ARGS=($${UPDATE}); \
	    SMAJOR="$${ARGS[1]%%.*}"; TMAJOR="$${ARGS[3]%%.*}"; \
	    if [ "$${SMAJOR}" != "$${TMAJOR}" ]; then \
	      if [[ "$${ARGS[0]}" == *$${SMAJOR}* ]]; then \
	        TARGET="$${ARGS[0]/$${SMAJOR}/$${TMAJOR}}"; \
	      else TARGET="$${ARGS[0]}/$${TMAJOR}"; fi; \
	      echo "update: $${ARGS[0]}@$${ARGS[2]} => $${TARGET}@$${ARGS[3]}"; \
	      sed --in-place --expression="s#$${ARGS[0]}#$${TARGET}#g" $(SOURCES); \
	    else \
	      echo "update: $${ARGS[0]}@$${ARGS[1]} => $${ARGS[3]}"; \
	      $(GO) get "$${ARGS[0]}@$${ARGS[3]}"; \
	    fi; \
	  done; \
	else $(GO) get -u ./...; fi; \
	$(GO) mod tidy -x -v -e -compat=$(GOVERSION) || exit 1;

#@ check for major and minor updates to latest versions.
update-deps?:: test-go update/go.mod?
update/go.mod?:: install-gomajor
	@if [ ! -f "go.mod" ]; then exit 0; fi; \
	$(call update-args,$(ARGS)); cp go.sum go.sum.~save~; \
	$(call update-list,$${ARGS},all); mv go.sum.~save~ go.sum;

update/go-make::
	@GOMAKE="github.com/tkrop/go-make"; \
	if [ -n "$(ARGS)" ]; then GOMAKE="$${GOMAKE}@$(ARGS)"; \
	else GOMAKE="$$($(call go-pkg-latest,$${GOMAKE}))"; fi; \
	if [ "$(ARGS)" != "current" ] || [ -z "$(ARGS)" ] && \
	    [ "$(gomake-version)" != "(devel)" ] ; then \
	  $(call emsg,info,updating [$${GOMAKE}]); \
	  $(GO) install $${GOMAKE} || \
	    ( $(call emsg,error,installing [$${GOMAKE}]) && exit 1 ) \
	fi;

#@ <version> # update this build environment to latest version.
update-make:: update/go-make $(TARGETS_UPDATE_MAKE)
$(TARGETS_UPDATE_MAKE):: update/%:
	@DIR="$${PWD}"; FILE="$*"; FILE="$${FILE##$${DIR}/}"; \
	$(call update-config,$(ARGS)); \
	if [ ! -e "$${DIR}/$${FILE}" ]; then \
	  $(call emsg,info,updating [$${FILE}] (untracked)); \
	elif [ -z "$$(diff "$${CONFIG}/$${FILE}" "$${DIR}/$${FILE}")" ]; then \
	  $(call emsg,info,updating [$${FILE}] (skipped)); \
	elif [ "$${FILE}" == "$(MAKEFILE)" ] && \
		[ -z "$$(grep -E "github.com/tkrop/go-make@v[0-9.]+$$" "$${FILE}")" ]; then \
	  $(call emsg,info,updating [$${FILE}] (aborted)); \
	elif [ -n "$$($(GIT) diff $${DIR}/$${FILE})" ] && \
	     [ "$(ARGS)" != "current" ]; then \
	  $(call emsg,warning,updating [$${FILE}] (blocked)); \
	else \
	  $(call emsg,info,updating [$${FILE}] (updated)); \
	  cp "$${CONFIG}/$${FILE}" "$${DIR}/$${FILE}"; \
	fi;

#@ <version> # check whether updates for build environment exist.
update-make?:: update/go-make $(TARGETS_UPDATE_MAKE?)
$(TARGETS_UPDATE_MAKE?):: update/%?:
	@DIR="$${PWD}"; FILE="$*"; FILE="$${FILE##$${DIR}/}"; \
	$(call update-config,$(ARGS)); \
	if [ ! -e "$${DIR}/$${FILE}" ]; then \
	  $(call emsg,info,updating [$${FILE}] (untracked)); \
	elif [ -z "$$(diff "$${CONFIG}/$${FILE}" "$${DIR}/$${FILE}")" ]; then \
	  $(call emsg,info,updating [$${FILE}] (unchanged)); \
	elif [ -n "$$($(GIT) diff $${DIR}/$${FILE})" -a \
	     "$(ARGS)" != "current" ]; then \
	  $(call emsg,warning,updating [$${FILE}] (blocked)); \
	elif [ "$${FILE}" == "$(MAKEFILE)" ] && \
		[ -z "$$(grep -E "github.com/tkrop/go-make@v[0-9.]+$$" "$${FILE}")"]; then \
	  $(call emsg,info,updating [$${FILE}] (aborted)); \
	else $(call emsg,info,updating [$${FILE}] (updated)); fi;

#@ update all tools required by the project.
update-tools:: $(TARGETS_UPDATE_GO) $(TARGETS_UPDATE_SH) $(TARGETS_UPDATE_NPM)
	$(GO) mod tidy -compat=${GOVERSION};

update-python::
	@if command -v pip3 >/dev/null 2>&1; then \
	  pip3 install --no-input --target "$(GOBIN)" --upgrade \
	    $$(pip3 list --outdated | awk '(NR > 2) { printf("%s ", $$1) }'); \
	fi;

#@ update-*: update the matched software command or service.
# update go tools used by the project.
$(TARGETS_UPDATE_GO):: update-%: $(GOBIN)
	@$(call go-install-module,$*,$(ARGS));
# update tools providing an install.sh tool.
$(TARGETS_UPDATE_SH):: update-%: $(GOBIN)
	@if command -v $*; then \
	  curl --silent --show-error --fail --location \
	    https://raw.githubusercontent.com/anchore/$*/main/install.sh | \
	    sh -s -- -b $(GOBIN); \
	fi;
# update npm based tools used by the project.
$(TARGETS_UPDATE_NPM):: update-%: $(GOBIN)
	@if command -v npm >/dev/null 2>&1 && command -v $*; then \
	  echo "npm update --global ^$*$$"; \
	  npm update --global $(filter $*-cli,$(TOOLS_NPM)); \
	fi;

## Debug: targets to debug the build environment and project.
#@ debug the make environment variables.
debug-make::
	@echo 'PATH $(PATH)'; \
	echo 'SHELL $(SHELL)'; \
	echo "BASH $(shell echo "$${0} - $${BASH_VERSION}")"; \
	echo 'AWK $(shell echo | awk -W version | head -n 1)'; \
	echo 'MAKEFILE_EXTS $(MAKEFILE_EXTS)'; \
	echo 'MAKEFILE_VARS $(MAKEFILE_VARS)'; \

#@ deubg the bash environment variables.
debug-bash::
	@echo "PATH $${PATH}"; \
	echo "SHELL $${SHELL}"; \
	echo "BASH $${0} - $${BASH_VERSION}"; \
	echo "AWK $$(echo | awk -W version | head -n 1)"; \

#@ debug the directory environment variables.
debug-dirs::
	@echo 'DIR_REAL $(DIR_REAL)'; \
	echo 'DIR_GIT $(DIR_GIT)'; \
	echo 'DIR_BUILD $(DIR_BUILD)'; \
	echo 'DIR_RUN $(DIR_RUN)'; \
	echo 'DIR_CRED $(DIR_CRED)'; \
	echo 'DIR_CONFIG $(DIR_CONFIG)'; \
	echo 'DIR_TEMP $(DIR_TEMP)'; \

#@ debug the file environment variables.
debug-files::
	@echo 'FILE_GOLANGCI $(FILE_GOLANGCI)'; \
	echo 'FILE_MARKDOWN $(FILE_MARKDOWN)'; \
	echo 'FILE_GITLEAKS $(FILE_GITLEAKS)'; \
	echo 'FILE_REVIVE $(FILE_REVIVE)'; \
	echo 'FILE_CODACY $(FILE_CODACY)'; \
	echo 'FILE_IMAGE $(FILE_IMAGE)'; \
	echo 'FILE_DEEPCOPY $(FILE_DEEPCOPY)'; \
	echo 'FILE_HEADER $(FILE_HEADER)'; \
	echo 'FILE_TARGETS $(FILE_TARGETS)'; \
	echo 'FILE_TARGETS_MAKE $(FILE_TARGETS_MAKE)'; \
	echo 'FILE_TARGETS_GOMAKE $(FILE_TARGETS_GOMAKE)'; \

#@ debug the source and module environment variables.
debug-sources::
	@echo 'SOURCES $(SOURCES)'; \
	echo 'MODULES $(MODULES)'; \

#@ debug then generated directories, sources, and targets.
debug-gen::
	@echo 'GEN_DIRS $(GEN_DIRS)'; \
	echo 'GEN_SOURCES $(GEN_SOURCES)'; \
	echo 'GEN_TARGETS $(GEN_TARGETS)';

#@ debug the command environment variables.
debug-commands::
	@echo 'COMMANDS $(COMMANDS)'; \
	echo 'COMMANDS_REGEX $(COMMANDS_REGEX)'; \
	echo 'COMMANDS_SH $(COMMANDS_SH)'; \
	echo 'COMMANDS_GO $(COMMANDS_GO)'; \
	echo 'COMMANDS_PKG $(COMMANDS_PKG)';

#@debug the mock environment variables.
debug-mocks::
	@echo 'MOCKS $(MOCKS)'; \
	echo 'MOCKS_TARGETS $(MOCKS_TARGETS)'; \
	echo 'MOCKS_SOURCES $(MOCKS_SOURCES)'; \
	echo 'MOCKS_ORIGINS $(MOCKS_ORIGINS)';

#@ debug the image environment variables.
debug-image::
	@echo 'IMAGE $(IMAGE)'; \
	echo 'IMAGE_CMD $(IMAGE_CMD)'; \
	echo 'IMAGE_PUSH $(IMAGE_PUSH)'; \
	echo 'IMAGE_FILES $(IMAGE_FILES)'; \
	echo 'IMAGE_NAMES $(IMAGE_NAMES)'; \
	echo 'IMAGE_DEPS $(shell $(call image-build-deps,$(IMAGE_NAMES)))'; \

#@ debug the target environment variables.
debug-targets::
	@echo 'TARGETS_ALL $(TARGETS_ALL)'; \
	echo 'TARGETS_INIT $(TARGETS_INIT)'; \
	echo 'TARGETS_COMMIT $(TARGETS_COMMIT)'; \
	echo 'TARGETS_TEST $(TARGETS_TEST)'; \
	echo 'TARGETS_LINT $(TARGETS_LINT)'; \
	echo 'TARGETS_CLEAN $(TARGETS_CLEAN)'; \
	echo 'TARGETS_UPDATE $(TARGETS_UPDATE)';

#@ debug the init target environment variables.
debug-targets-init::
	@echo 'TARGETS_INIT $(TARGETS_INIT)'; \
	echo 'TARGETS_INIT_ALL $(TARGETS_INIT_ALL)'; \
	echo 'TARGETS_INIT_MAKE $(TARGETS_INIT_MAKE)'; \
	echo 'TARGETS_INIT_CODACY $(TARGETS_INIT_CODACY)';

#@ debug the test target environment variables.
debug-targets-test::
	@echo 'TARGETS_TEST $(TARGETS_TEST)'; \
	echo 'TARGETS_TEST_INIT $(TARGETS_TEST_INIT)';

#@ debug the lint target environment variables.
debug-targets-lint::
	@echo 'TARGETS_LINT $(TARGETS_LINT)'; \
	echo 'TARGETS_LINT_CODACY_CLIENTS $(TARGETS_LINT_CODACY_CLIENTS)'; \
	echo 'TARGETS_LINT_CODACY_BINARIES $(TARGETS_LINT_CODACY_BINARIES)';

#@ debug the build target environment variables.
debug-targets-build::
	@echo 'TARGETS_BUILD $(TARGETS_BUILD)'; \
	echo 'TARGETS_BUILD_LINUX $(TARGETS_BUILD_LINUX)';

#@ debug the image target environment variables.
debug-targets-image::
	@echo 'TARGETS_IMAGE_BUILD $(TARGETS_IMAGE_BUILD)'; \
	echo 'TARGETS_IMAGE_PUSH $(TARGETS_IMAGE_PUSH)'; \

#@ debug the install target environment variables.
debug-targets-install::
	@echo 'TARGETS_INSTALL $(TARGETS_INSTALL)'; \
	echo 'TARGETS_INSTALL_GO $(TARGETS_INSTALL_GO)'; \
	echo 'TARGETS_INSTALL_SH $(TARGETS_INSTALL_SH)'; \
	echo 'TARGETS_INSTALL_NPM $(TARGETS_INSTALL_NPM)'; \
	echo 'TARGETS_INSTALL_ALL $(TARGETS_INSTALL_ALL)';

#@ debug the uninstall target environment variables.
debug-targets-uninstall::
	@echo 'TARGETS_UNINSTALL $(TARGETS_UNINSTALL)'; \
	echo 'TARGETS_UNINSTALL_GO $(TARGETS_UNINSTALL_GO)'; \
	echo 'TARGETS_UNINSTALL_SH $(TARGETS_UNINSTALL_SH)'; \
	echo 'TARGETS_UNINSTALL_NPM $(TARGETS_UNINSTALL_NPM)'; \
	echo 'TARGETS_UNINSTALL_CODACY $(TARGETS_UNINSTALL_CODACY)'; \
	echo 'TARGETS_UNINSTALL_ALL $(TARGETS_UNINSTALL_ALL)'; \
	echo 'GOMAKE_VERSION $(gomake-version)';

#@ debug the run target environment variables.
debug-targets-run::
	@echo 'TARGETS_RUN $(TARGETS_RUN)'; \
	echo 'TARGETS_RUN_GO $(TARGETS_RUN_GO)'; \
	echo 'TARGETS_RUN_IMAGE $(TARGETS_RUN_IMAGE)'; \
	echo 'TARGETS_RUN_CLEAN $(TARGETS_RUN_CLEAN)';

#@ debug the clean target environment variables.
debug-targets-clean::
	@echo 'TARGETS_CLEAN $(TARGETS_CLEAN)'; \
	echo 'TARGETS_CLEAN_ALL $(TARGETS_CLEAN_ALL)'; \
	echo 'TARGETS_CLEAN_RUN $(TARGETS_CLEAN_RUN)';

#@ debug the update target environment variables.
debug-targets-update::
	@echo 'TARGETS_UPDATE $(TARGETS_UPDATE)'; \
	echo 'TARGETS_UPDATE? $(TARGETS_UPDATE?)'; \
	echo 'TARGETS_UPDATE_GO $(TARGETS_UPDATE_GO)'; \
	echo 'TARGETS_UPDATE_SH $(TARGETS_UPDATE_SH)'; \
	echo 'TARGETS_UPDATE_NPM $(TARGETS_UPDATE_NPM)'; \
	echo 'TARGETS_UPDATE_MAKE $(TARGETS_UPDATE_MAKE)'; \
	echo 'TARGETS_UPDATE_MAKE? $(TARGETS_UPDATE_MAKE?)'; \
	echo 'TARGETS_UPDATE_ALL $(TARGETS_UPDATE_ALL)'; \
	echo 'TARGETS_UPDATE_ALL? $(TARGETS_UPDATE_ALL?)'; \


## Custom: custom extension targets.
# Include makefiles with custom targets.
include $(MAKEFILE_EXTS)
